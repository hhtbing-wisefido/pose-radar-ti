/**
 * @file pose_mss_sdk_integration.c.example
 * @brief MSS 模块 SDK 集成示例代码
 * 
 * 此文件展示如何将 mmWave SDK 集成到 pose_mss.c 中
 * 
 * 使用方法:
 * 1. 确保已安装 mmWave SDK 6.x
 * 2. 将此文件内容合并到 pose_mss.c
 * 3. 替换所有TODO标记的函数实现
 * 
 * @version 1.0.0
 * @date 2025-12-09
 */

/*******************************************************************************
 * SDK 头文件包含 (添加到 pose_mss.c 顶部)
 ******************************************************************************/

/* mmWave SDK 控制模块 */
#include <ti/control/mmwave/mmwave.h>
#include <ti/common/sys_common.h>

/* mmWave SDK 数据处理单元 (DPU) */
#include <ti/datapath/dpu/rangeproc/rangeprochwa.h>
#include <ti/datapath/dpu/cfar/cfarcaproc.h>
#include <ti/datapath/dpu/trackerproc/trackerproc.h>

/* mmWave SDK 驱动 */
#include <ti/drivers/edma/edma.h>
#include <ti/drivers/uart/UART.h>
#include <ti/drivers/mailbox/mailbox.h>

/* mmWave SDK 工具 */
#include <ti/utils/mathutils/mathutils.h>

/*******************************************************************************
 * DPU 句柄 (添加到全局变量区)
 ******************************************************************************/

/* Range FFT DPU 句柄 */
static DPU_RangeProcHWA_Handle gRangeProc Handle = NULL;

/* CFAR DPU 句柄 */
static DPU_CFARCAProcHWA_Handle gCfarProcHandle = NULL;

/* 跟踪器 DPU 句柄 */
static DPU_TrackerProc_Handle gTrackerHandle = NULL;

/* mmWave 控制句柄 */
static MMWave_Handle gMmwaveHandle = NULL;

/*******************************************************************************
 * 数据缓冲区 (L3 共享内存)
 ******************************************************************************/

/* Radar Cube (Range FFT 输出) */
#pragma DATA_SECTION(gRadarCube, ".radarCube")
static uint16_t gRadarCube[CFG_NUM_VIRTUAL_ANTENNAS]
                          [CFG_NUM_CHIRPS_PER_FRAME]
                          [CFG_NUM_RANGE_BINS];

/* 检测矩阵 (CFAR 输入) */
#pragma DATA_SECTION(gDetectionMatrix, ".detectionMatrix")
static uint16_t gDetectionMatrix[CFG_NUM_VIRTUAL_ANTENNAS]
                                [CFG_NUM_RANGE_BINS];

/* 点云缓冲区 (CFAR 输出) */
#pragma DATA_SECTION(gPointCloudBuf, ".pointCloud")
static PointCloud_t gPointCloudBuf[MAX_NUM_DETECTED_POINTS];

/* 跟踪目标缓冲区 */
#pragma DATA_SECTION(gTrackerTargetsBuf, ".trackerTargets")
static TrackerTarget_t gTrackerTargetsBuf[MAX_NUM_TRACKS];

/*******************************************************************************
 * MSS 初始化 - SDK 集成版本
 ******************************************************************************/

PoseError_e MSS_initDataPath(void)
{
    int32_t retVal = 0;
    
    /* ========================================================================
     * 1. 初始化 Range FFT DPU
     * ======================================================================*/
    
    DPU_RangeProcHWA_InitParams rangeInitParams;
    memset(&rangeInitParams, 0, sizeof(rangeInitParams));
    
    /* 配置初始化参数 */
    rangeInitParams.hwaHandle = gMmwMssMCB.hwaHandle;  /* HWA 硬件句柄 */
    rangeInitParams.edmaHandle = gMmwMssMCB.edmaHandle; /* EDMA 句柄 */
    
    /* 初始化 Range FFT DPU */
    retVal = DPU_RangeProcHWA_init(&rangeInitParams, &gRangeProcHandle);
    if (retVal != 0) {
        DebugP_log("Range FFT DPU init failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* 配置 Range FFT DPU */
    DPU_RangeProcHWA_Config rangeCfg;
    memset(&rangeCfg, 0, sizeof(rangeCfg));
    
    rangeCfg.staticCfg.ADCBufData.dataProperty.dataFmt = 0; /* 复数格式 */
    rangeCfg.staticCfg.ADCBufData.dataProperty.interleave = 1; /* 交织 */
    rangeCfg.staticCfg.ADCBufData.dataProperty.numAdcSamples = CFG_NUM_ADC_SAMPLES;
    rangeCfg.staticCfg.ADCBufData.dataProperty.numChirpsPerChirpEvent = 1;
    rangeCfg.staticCfg.ADCBufData.dataProperty.numRxAntennas = CFG_NUM_RX_ANTENNAS;
    
    rangeCfg.staticCfg.numRangeBins = CFG_NUM_RANGE_BINS;
    rangeCfg.staticCfg.numChirpsPerFrame = CFG_NUM_CHIRPS_PER_FRAME;
    rangeCfg.staticCfg.numVirtualAntennas = CFG_NUM_VIRTUAL_ANTENNAS;
    
    /* 窗函数配置 */
    rangeCfg.staticCfg.window = DPU_RANGEPROCHWA_WINDOW_HAMMING;
    
    /* 输出配置 */
    rangeCfg.staticCfg.radarCubeFormat = DPC_OBJDET_DPIF_RADARCUBE_FORMAT_6;
    rangeCfg.dynCfg.radarCube.data = (void*)gRadarCube;
    rangeCfg.dynCfg.radarCube.dataSize = sizeof(gRadarCube);
    
    retVal = DPU_RangeProcHWA_config(gRangeProcHandle, &rangeCfg);
    if (retVal != 0) {
        DebugP_log("Range FFT DPU config failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* ========================================================================
     * 2. 初始化 CFAR DPU
     * ======================================================================*/
    
    DPU_CFARCAProcHWA_InitParams cfarInitParams;
    memset(&cfarInitParams, 0, sizeof(cfarInitParams));
    
    cfarInitParams.hwaHandle = gMmwMssMCB.hwaHandle;
    cfarInitParams.edmaHandle = gMmwMssMCB.edmaHandle;
    
    retVal = DPU_CFARCAProcHWA_init(&cfarInitParams, &gCfarProcHandle);
    if (retVal != 0) {
        DebugP_log("CFAR DPU init failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* 配置 CFAR DPU */
    DPU_CFARCAProcHWA_Config cfarCfg;
    memset(&cfarCfg, 0, sizeof(cfarCfg));
    
    /* CFAR 参数 */
    cfarCfg.staticCfg.cfarCfg.averageMode = DPU_CFARCAPROCHWA_CFAR_CA;
    cfarCfg.staticCfg.cfarCfg.guardLen = CFAR_GUARD_LEN;
    cfarCfg.staticCfg.cfarCfg.noiseWinLen = CFAR_NOISE_LEN;
    cfarCfg.staticCfg.cfarCfg.thresholdScale = powf(10.0f, CFAR_THRESHOLD_DB / 10.0f);
    
    /* 峰值分组 */
    cfarCfg.staticCfg.cfarCfg.peakGroupingEn = 1;
    cfarCfg.staticCfg.cfarCfg.peakGroupingScheme = DPU_CFARCAPROCHWA_PEAK_GROUPING_DET_MATRIX_BASED;
    
    /* 输入配置 */
    cfarCfg.dynCfg.detMatrix.data = (void*)gDetectionMatrix;
    cfarCfg.dynCfg.detMatrix.dataSize = sizeof(gDetectionMatrix);
    
    /* 输出配置 */
    cfarCfg.dynCfg.cfarRngDopSnrList = (DPIF_CFARDetList*)gPointCloudBuf;
    cfarCfg.dynCfg.cfarRngDopSnrListSize = MAX_NUM_DETECTED_POINTS;
    
    retVal = DPU_CFARCAProcHWA_config(gCfarProcHandle, &cfarCfg);
    if (retVal != 0) {
        DebugP_log("CFAR DPU config failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* ========================================================================
     * 3. 初始化 跟踪器 DPU
     * ======================================================================*/
    
    DPU_TrackerProc_InitParams trackerInitParams;
    memset(&trackerInitParams, 0, sizeof(trackerInitParams));
    
    retVal = DPU_TrackerProc_init(&trackerInitParams, &gTrackerHandle);
    if (retVal != 0) {
        DebugP_log("Tracker DPU init failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* 配置跟踪器 */
    DPU_TrackerProc_Config trackerCfg;
    memset(&trackerCfg, 0, sizeof(trackerCfg));
    
    /* 跟踪参数 */
    trackerCfg.staticCfg.maxNumTracks = MAX_NUM_TRACKS;
    trackerCfg.staticCfg.maxNumPoints = MAX_NUM_DETECTED_POINTS;
    
    /* 门限参数 */
    trackerCfg.staticCfg.gatingParams.length = 3.0f;   /* 3米 */
    trackerCfg.staticCfg.gatingParams.width = 2.0f;    /* 2米 */
    trackerCfg.staticCfg.gatingParams.height = 2.0f;   /* 2米 */
    trackerCfg.staticCfg.gatingParams.vel = 4.0f;      /* 4m/s */
    
    /* 状态转移参数 */
    trackerCfg.staticCfg.stateParams.det2actThre = 3;  /* 检测到激活 */
    trackerCfg.staticCfg.stateParams.det2freeThre = 5; /* 检测到释放 */
    trackerCfg.staticCfg.stateParams.active2freeThre = 10; /* 激活到释放 */
    
    /* 分配参数 */
    trackerCfg.staticCfg.allocationParams.snrThre = 10.0f;   /* SNR阈值 10dB */
    trackerCfg.staticCfg.allocationParams.velocityThre = 0.1f; /* 速度阈值 */
    
    retVal = DPU_TrackerProc_config(gTrackerHandle, &trackerCfg);
    if (retVal != 0) {
        DebugP_log("Tracker DPU config failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    DebugP_log("Data path initialized successfully\n");
    return POSE_OK;
}

/*******************************************************************************
 * 帧处理 - SDK 集成版本
 ******************************************************************************/

PoseError_e MSS_processFrame(uint32_t frameNum)
{
    int32_t retVal = 0;
    PoseError_e poseRet = POSE_OK;
    
    if (!gMmwMssMCB.isRunning) {
        return POSE_ERROR_NOT_READY;
    }
    
    gMmwMssMCB.frameCount = frameNum;
    
    /* ========================================================================
     * 1. Range FFT 处理 (在 HWA 上执行)
     * ======================================================================*/
    
    DPU_RangeProcHWA_OutParams rangeOutParams;
    memset(&rangeOutParams, 0, sizeof(rangeOutParams));
    
    retVal = DPU_RangeProcHWA_process(gRangeProcHandle, &rangeOutParams);
    if (retVal != 0) {
        DebugP_log("Range FFT process failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    /* Range FFT 输出在 gRadarCube 中 */
    
    /* ========================================================================
     * 2. 生成检测矩阵 (对所有虚拟天线求和)
     * ======================================================================*/
    
    memset(gDetectionMatrix, 0, sizeof(gDetectionMatrix));
    
    for (uint32_t ant = 0; ant < CFG_NUM_VIRTUAL_ANTENNAS; ant++) {
        for (uint32_t bin = 0; bin < CFG_NUM_RANGE_BINS; bin++) {
            /* 对所有 chirps 取平均 */
            uint32_t sum = 0;
            for (uint32_t chirp = 0; chirp < CFG_NUM_CHIRPS_PER_FRAME; chirp++) {
                sum += gRadarCube[ant][chirp][bin];
            }
            gDetectionMatrix[ant][bin] = (uint16_t)(sum / CFG_NUM_CHIRPS_PER_FRAME);
        }
    }
    
    /* ========================================================================
     * 3. CFAR 检测
     * ======================================================================*/
    
    DPU_CFARCAProcHWA_OutParams cfarOutParams;
    memset(&cfarOutParams, 0, sizeof(cfarOutParams));
    
    retVal = DPU_CFARCAProcHWA_process(gCfarProcHandle, &cfarOutParams);
    if (retVal != 0) {
        DebugP_log("CFAR process failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    uint32_t numDetected = cfarOutParams.numObjOut;
    
    /* 转换 CFAR 输出为点云格式 */
    for (uint32_t i = 0; i < numDetected && i < MAX_NUM_DETECTED_POINTS; i++) {
        DPIF_CFARDetObj* cfarObj = &cfarOutParams.cfarDetObjList[i];
        
        /* 转换为笛卡尔坐标 */
        float range = (float)cfarObj->rangeIdx * CFG_RANGE_RESOLUTION_M;
        float doppler = (float)cfarObj->dopplerIdx * CFG_VELOCITY_RESOLUTION_MPS;
        
        gPointCloudBuf[i].x = range; /* 简化: 假设正前方 */
        gPointCloudBuf[i].y = 0.0f;
        gPointCloudBuf[i].z = 0.0f;
        gPointCloudBuf[i].velocity = doppler;
        gPointCloudBuf[i].snr = (float)cfarObj->snr;
    }
    
    gMmwMssMCB.pointCloud = gPointCloudBuf;
    gMmwMssMCB.numDetectedPoints = numDetected;
    
    /* ========================================================================
     * 4. 目标跟踪
     * ======================================================================*/
    
    if (numDetected >= ML_TYPE3_FEATURE_MIN_COUNT) {
        
        DPU_TrackerProc_InParams trackerInParams;
        DPU_TrackerProc_OutParams trackerOutParams;
        
        memset(&trackerInParams, 0, sizeof(trackerInParams));
        memset(&trackerOutParams, 0, sizeof(trackerOutParams));
        
        /* 输入点云 */
        trackerInParams.pointCloud = (DPIF_PointCloudCartesian*)gPointCloudBuf;
        trackerInParams.numPoints = numDetected;
        
        /* 输出跟踪目标 */
        trackerOutParams.targetList = (DPU_TrackerProc_TargetDescr*)gTrackerTargetsBuf;
        trackerOutParams.maxNumTracks = MAX_NUM_TRACKS;
        
        retVal = DPU_TrackerProc_process(gTrackerHandle, &trackerInParams, &trackerOutParams);
        if (retVal == 0) {
            gMmwMssMCB.trackerTargets = gTrackerTargetsBuf;
            gMmwMssMCB.numTrackedTargets = trackerOutParams.numTracks;
        }
    }
    
    /* ========================================================================
     * 5. 特征提取
     * ======================================================================*/
    
    if (gMmwMssMCB.numTrackedTargets > 0 && 
        gMmwMssMCB.numDetectedPoints >= ML_TYPE3_FEATURE_MIN_COUNT) {
        
        float features[ML_TYPE3_FEATURE_COUNT];
        
        poseRet = MSS_extractFeatures(
            gMmwMssMCB.pointCloud,
            gMmwMssMCB.numDetectedPoints,
            &gMmwMssMCB.trackerTargets[0],  /* 使用第一个跟踪目标 */
            features
        );
        
        if (poseRet == POSE_OK) {
            /* 更新特征缓冲区 */
            MSS_updateFeatureBuffer(features);
        }
    }
    
    /* ========================================================================
     * 6. ML 推理
     * ======================================================================*/
    
    if (MSS_canRunInference()) {
        PoseClassResult_t result;
        
        poseRet = MSS_runInference(&result);
        
        if (poseRet == POSE_OK && result.isValid) {
            /* 保存结果 */
            memcpy(&gMmwMssMCB.classResult, &result, sizeof(PoseClassResult_t));
            gMmwMssMCB.mlInferenceCount++;
            
            /* 发送 ML 结果到 UART */
            MSS_sendMLResult(&result);
            
#if ML_DEBUG_PRINT_ENABLED
            MSS_debugPrintResult(&result);
#endif
        } else {
            gMmwMssMCB.mlErrorCount++;
        }
    }
    
    /* ========================================================================
     * 7. 发送其他数据到 UART
     * ======================================================================*/
    
    /* 发送帧头 */
    MSS_sendFrameHeader(frameNum, gMmwMssMCB.numDetectedPoints);
    
    /* 发送点云 */
    MSS_sendPointCloud(gMmwMssMCB.pointCloud, gMmwMssMCB.numDetectedPoints);
    
    /* 发送跟踪目标 */
    MSS_sendTrackerTargets(gMmwMssMCB.trackerTargets, gMmwMssMCB.numTrackedTargets);
    
    return POSE_OK;
}

/*******************************************************************************
 * 传感器控制 - SDK 集成版本
 ******************************************************************************/

PoseError_e MSS_sensorStart(void)
{
    int32_t retVal;
    MMWave_StartCfg startCfg;
    
    if (gMmwMssMCB.state == MSS_STATE_ERROR) {
        return POSE_ERROR_NOT_READY;
    }
    
    /* 配置启动参数 */
    memset(&startCfg, 0, sizeof(startCfg));
    startCfg.dfeDataOutputMode = MMWave_DFEDataOutputMode_FRAME;
    startCfg.mssDataOutputMode = MMWave_DataOutputMode_ADVANCED_FRAME;
    
    /* 启动 mmWave */
    retVal = MMWave_start(gMmwaveHandle, &startCfg);
    if (retVal != 0) {
        DebugP_log("MMWave start failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    gMmwMssMCB.sensorStarted = 1;
    gMmwMssMCB.isRunning = 1;
    gMmwMssMCB.state = MSS_STATE_RUNNING;
    gMmwMssMCB.frameCount = 0;
    
    DebugP_log("Sensor started successfully\n");
    return POSE_OK;
}

PoseError_e MSS_sensorStop(void)
{
    int32_t retVal;
    
    /* 停止 mmWave */
    retVal = MMWave_stop(gMmwaveHandle);
    if (retVal != 0) {
        DebugP_log("MMWave stop failed: %d\n", retVal);
        return POSE_ERROR_INVALID_PARAM;
    }
    
    gMmwMssMCB.sensorStarted = 0;
    gMmwMssMCB.isRunning = 0;
    gMmwMssMCB.state = MSS_STATE_STOPPED;
    
    DebugP_log("Sensor stopped successfully\n");
    return POSE_OK;
}

/*******************************************************************************
 * 示例: 帧中断处理函数
 ******************************************************************************/

/**
 * @brief 帧开始中断回调
 */
void MSS_frameStartCallback(MMWave_Handle handle)
{
    /* 帧开始 - 可以在这里做预处理 */
    (void)handle;
}

/**
 * @brief 帧结束中断回调
 */
void MSS_frameStopCallback(MMWave_Handle handle, uint32_t frameNum)
{
    /* 帧结束 - 触发帧处理 */
    (void)handle;
    
    /* 通知主任务处理此帧 */
    MSS_processFrame(frameNum);
}
