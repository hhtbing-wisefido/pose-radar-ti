# AWRL6844的CCS Flash配置深度解析

**创建日期**: 2026年1月6日  
**文档类型**: 技术深度分析  
**目标读者**: 需要理解CCS Flash烧录机制的开发者

---

## 📋 目录

- [1. CCS Flash vs Debug 核心区别](#1-ccs-flash-vs-debug-核心区别)
- [2. AWRL6844的存储器架构](#2-awrl6844的存储器架构)
- [3. CCS Flash烧录失败的根本原因](#3-ccs-flash烧录失败的根本原因)
- [4. CCS Flash配置要素](#4-ccs-flash配置要素)
- [5. 为什么arprog是标准方案](#5-为什么arprog是标准方案)
- [6. CCS Flash配置的可行性分析](#6-ccs-flash配置的可行性分析)
- [7. 结论与建议](#7-结论与建议)

---

## 1. CCS Flash vs Debug 核心区别

### 1.1 Debug Project（调试模式）

**执行位置**: RAM（易失性存储器）  
**目标地址**: `0x00000000` - TCMA RAM起始地址  
**编译产物**: `.out`文件（ELF格式）  
**加载方式**: JTAG直接加载到RAM  

**工作流程**：
```
1. JTAG连接 → 握手成功
2. 复位CPU   → PC寄存器清零
3. 加载.out  → JTAG传输代码到TCMA (0x0)
4. 设置PC    → 指向入口点_vectors (0x0)
5. 运行程序  → CPU从RAM执行
6. 断点调试  → JTAG实时控制
```

**Linker配置示例**（RAM执行）：
```c
MEMORY {
    RESET_VECTORS (X)  : origin=0x00000000 length=0x100
    TCMA_RAM      (RX) : origin=0x00000100 length=0x7FFF0
    TCMB_RAM      (RW) : origin=0x08000000 length=0x40000
}

SECTIONS {
    .vectors : {} > RESET_VECTORS
    .text    : {} > TCMA_RAM
    .data    : {} > TCMA_RAM
}
```

**特点**：
- ✅ 快速开发迭代
- ✅ 支持实时调试
- ✅ 支持断点/单步执行
- ❌ 断电后程序消失
- ❌ 不适合生产部署

---

### 1.2 Flash Project（烧录模式）

**执行位置**: QSPI Flash（非易失性存储器）  
**目标地址**: `0x60100000` - QSPI Flash起始地址  
**编译产物**: `.appimage`文件（MetaImage格式）  
**烧录方式**: 需要Flash烧录器程序  

**工作流程**：
```
1. JTAG连接      → 握手成功
2. 加载Flasher   → 将Flash烧录器加载到RAM
3. 运行Flasher   → Flasher程序初始化QSPI控制器
4. 传输固件      → JTAG将.appimage数据发送给Flasher
5. Flasher烧录   → 写入QSPI Flash (0x60100000起始)
6. 验证数据      → 读回Flash验证校验和
7. 完成烧录      → 断开JTAG
8. 上电启动      → ROM Bootloader加载Flash内容
```

**Linker配置示例**（Flash执行）：
```c
MEMORY {
    /* QSPI Flash - XIP模式 */
    FLASH (RX) : origin=0x60100000 length=0x400000  // 4MB
    
    /* RAM用于数据段 */
    TCMA_RAM (RW) : origin=0x00000000 length=0x80000
    TCMB_RAM (RW) : origin=0x08000000 length=0x40000
}

SECTIONS {
    .vectors : {} > FLASH  // 中断向量表在Flash
    .text    : {} > FLASH  // 代码在Flash
    .data    : {} > TCMA_RAM  // 数据在RAM
}
```

**特点**：
- ✅ 断电后程序保留
- ✅ 适合生产部署
- ✅ 无需JTAG即可运行
- ❌ 烧录速度慢（约1分钟）
- ❌ 配置复杂
- ❌ 调试困难（需要XIP支持）

---

## 2. AWRL6844的存储器架构

### 2.1 存储器映射表

| 地址范围 | 大小 | 名称 | 类型 | 用途 | 访问速度 |
|---------|------|------|------|------|---------|
| `0x00000000 - 0x0007FFFF` | 512KB | TCMA RAM | SRAM | R5F代码/数据 | 最快 |
| `0x08000000 - 0x0803FFFF` | 256KB | TCMB RAM | SRAM | R5F堆栈 | 最快 |
| `0x00800000 - 0x00FFFFFF` | 8MB | DSS L3 RAM | SRAM | C66x代码/数据 | 快 |
| `0x60000000 - 0x67FFFFFF` | 128MB | QSPI Flash | Flash | 固件存储 | 中等 |
| `0x60100000 - 0x604FFFFF` | 4MB | **App区域** | Flash | 应用固件 | 中等 |
| `0x70000000 - 0x7FFFFFFF` | 256MB | DSS外设 | MMIO | 雷达外设 | 慢 |

### 2.2 启动流程

```
上电 → ROM Bootloader (固化在芯片内)
       ↓
   检查SOP跳线 (S7/S8)
       ↓
   ┌──────────────────┐
   │ FUNCTIONAL模式   │ S7=ON, S8=ON
   │ (正常运行)       │
   └────────┬─────────┘
            ↓
   读取QSPI Flash @ 0x60100000
            ↓
   解析MetaImage Header
            ↓
   加载R5F固件到TCMA (0x0)
            ↓
   加载C66x固件到DSS L3 (0x800000)
            ↓
   启动R5F和C66x核心
            ↓
   运行应用程序
```

### 2.3 Flash分区结构

```
QSPI Flash 布局 (4MB可用空间)
┌─────────────────────────────────────┐
│ 0x60100000 - 0x60101FFF (8KB)       │ 保留
├─────────────────────────────────────┤
│ 0x60102000 - 0x60141FFF (256KB)     │ SBL区域
│                                     │ (Secondary Bootloader)
├─────────────────────────────────────┤
│ 0x60142000 - 0x604FFFFF (~3.7MB)   │ 应用固件区域
│                                     │ (App MetaImage)
│   - R5F代码段                       │
│   - C66x代码段                      │
│   - RFS固件                         │
│   - 数据段                          │
└─────────────────────────────────────┘
```

**偏移量计算**：
- SBL偏移: `0x2000` = 8192字节
- App偏移: `0x42000` = 270336字节

---

## 3. CCS Flash烧录失败的根本原因

### 3.1 你遇到的错误

```
Cortex_R5_0: File Loader: Verification failed: 
Values at address 0x00000000 do not match 
(expected: 0x18, actual: 0xAB)
Please verify target memory and memory map.
```

### 3.2 错误分析

**问题1: 地址映射错误**

CCS尝试验证的地址：
```
验证地址: 0x00000000 (TCMA RAM起始地址)
期望值:   0x18 (来自.out文件)
实际值:   0xAB (ROM/未初始化RAM内容)
```

**为什么会出错**：
1. 你的项目使用的是**RAM执行linker.cmd** (`origin=0x0`)
2. CCS的**Flash Project**命令尝试将固件写入Flash
3. 但验证时读取的是**RAM地址0x0**，不是Flash地址
4. RAM内容未写入，所以验证失败

**问题2: 缺少Flash插件配置**

CCS需要以下配置才能烧录QSPI Flash：

```xml
<!-- .ccxml中需要的Flash配置 -->
<flashProgrammer>
    <device name="AWRL6844">
        <flashDevice type="QSPI">
            <baseAddress>0x60100000</baseAddress>
            <flashLoader>FlashLoaderAWRL6844.out</flashLoader>
            <algorithm>qspi_flash_writer.out</algorithm>
        </flashDevice>
    </device>
</flashProgrammer>
```

但**CCS 20.4没有AWRL6844的Flash插件**！

**问题3: MetaImage格式要求**

QSPI Flash需要特殊的**MetaImage格式**：

```
MetaImage结构：
┌─────────────────────────┐
│ Header (128字节)        │ Magic: 0xA5A5A5A5
│  - 文件数量             │ 
│  - 总大小               │
│  - 校验和               │
├─────────────────────────┤
│ Core Image 0 (R5F)      │
│  - 子Header             │
│  - Load Address         │
│  - 代码段               │
├─────────────────────────┤
│ Core Image 1 (C66x)     │
│  - 子Header             │
│  - Load Address         │
│  - 代码段               │
└─────────────────────────┘
```

普通的`.out`文件**不是MetaImage格式**，必须用`buildImage_creator.exe`转换。

---

## 4. CCS Flash配置要素

### 4.1 需要的文件和工具

要在CCS中实现Flash烧录，需要：

| 组件 | 文件名 | 作用 | 存在情况 |
|------|--------|------|---------|
| **Flash Loader** | `FlashLoaderAWRL6844.out` | 在RAM中运行的烧录程序 | ❌ 不存在 |
| **Flash Algorithm** | `qspi_flash_writer.out` | QSPI写入算法 | ❌ 不存在 |
| **Target Config** | `AWRL6844_flash.ccxml` | Flash设备配置 | ❌ 需要创建 |
| **Flash Linker** | `linker_flash.cmd` | Flash地址映射 | ❌ 需要创建 |
| **Image Converter** | `buildImage_creator.exe` | .out → .appimage | ✅ 存在于SDK |

### 4.2 Flash Loader的工作原理

**Flash Loader是一个小程序**，运行在目标设备的RAM中：

```c
// FlashLoader伪代码
void FlashLoader_main() {
    // 1. 初始化QSPI控制器
    QSPI_init();
    QSPI_set_clock(50MHz);
    
    // 2. 等待JTAG发送数据
    while (1) {
        // 接收JTAG命令
        cmd = JTAG_receive_command();
        
        if (cmd == CMD_WRITE_FLASH) {
            addr = JTAG_receive_address();
            data = JTAG_receive_data();
            
            // 3. 写入Flash
            QSPI_write(addr, data);
            
            // 4. 验证
            verify = QSPI_read(addr);
            if (verify != data) {
                JTAG_send_error();
            }
        }
    }
}
```

**CCS查找Flash Loader的位置**：
```
C:\ti\ccs2040\ccs\ccs_base\arm\FlashLoaderCC26x4.out  ← CC26x4系列
C:\ti\ccs2040\ccs\ccs_base\arm\FlashLoaderCC26x2.out  ← CC26x2系列
...
(但没有 FlashLoaderAWRL6844.out!)
```

### 4.3 为什么AWRL6844缺少Flash Loader

**原因1: 复杂的启动流程**

AWRL6844不是简单的"代码放Flash就能运行"：
```
需要SBL → 解析MetaImage → 加载R5F → 加载C66x → 启动双核
```

这比单核MCU复杂得多。

**原因2: TI的设计理念**

TI针对mmWave雷达芯片的策略：
- ❌ **不提供CCS Flash插件**
- ✅ **提供命令行烧录工具** (arprog)
- ✅ **提供图形界面工具** (SDK Visualizer)

原因：
1. Flash布局复杂（SBL + App + RFS）
2. 需要特殊的MetaImage格式
3. 命令行工具更适合自动化生产

---

## 5. 为什么arprog是标准方案

### 5.1 arprog的工作原理

**arprog = Advanced UART Flash Programmer**

```
PC (arprog.exe)  ←UART→  AWRL6844 (ROM Bootloader)
       ↓                          ↓
   解析.appimage              进入Flash模式
       ↓                          ↓
   发送XMODEM协议            接收固件数据
       ↓                          ↓
   校验+重传                   写入QSPI Flash
       ↓                          ↓
   完成                        验证完整性
```

**关键优势**：

1. **无需JTAG**
   - 只需USB转串口（XDS110自带）
   - 成本低，速度快

2. **ROM Bootloader支持**
   - 芯片内置的Flash烧录功能
   - 可靠性高

3. **支持MetaImage格式**
   - 直接烧录.appimage
   - 自动处理多核映像

4. **支持Flash Header创建**
   - `-cf`参数动态创建头部
   - 简化偏移量烧录

### 5.2 arprog vs CCS Flash对比

| 特性 | arprog | CCS Flash |
|------|--------|-----------|
| **连接方式** | UART (COM口) | JTAG (XDS110) |
| **烧录速度** | ~40秒 (374KB) | 理论更快，但配置困难 |
| **依赖工具** | 仅需arprog.exe | 需要Flash Loader + Algorithm |
| **支持格式** | .appimage (MetaImage) | 需要转换.out |
| **官方支持** | ✅ TI官方标准方案 | ❌ 无官方Flash插件 |
| **自动化** | ✅ 命令行易集成 | ❌ GUI操作为主 |
| **可靠性** | ✅ 经过TI验证 | ❓ 需要自己配置 |
| **学习成本** | 低（简单命令） | 高（需要深入理解） |

### 5.3 TI官方推荐流程

```
开发阶段：
CCS Debug → RAM执行 → JTAG调试 → 快速迭代

生产阶段：
CCS编译 → 生成.appimage → arprog烧录 → 断电测试
```

**不推荐**：
```
CCS Flash → 配置复杂 → 容易出错 → 不适合生产
```

---

## 6. CCS Flash配置的可行性分析

### 6.1 理论上可行的方案

**步骤1: 创建Flash Loader**

需要编写一个RAM执行的程序：
```c
// flash_loader_awrl6844.c
#include <qspi.h>
#include <jtag_interface.h>

void main() {
    QSPI_init();
    
    while(1) {
        // 实现JTAG Flash烧录协议
        // 需要深入理解CCS的Flash Plugin协议
    }
}
```

**步骤2: 配置.ccxml**

```xml
<configuration>
    <connection>
        <instance href="AWRL68xx.xml"/>
        <flash_programmer>
            <device name="QSPI_FLASH">
                <flash_device>
                    <base_address>0x60100000</base_address>
                    <size>0x400000</size>
                    <loader>flash_loader_awrl6844.out</loader>
                    <algorithm>qspi_write_algo.out</algorithm>
                </flash_device>
            </device>
        </flash_programmer>
    </connection>
</configuration>
```

**步骤3: 创建Flash版linker.cmd**

```c
MEMORY {
    QSPI_FLASH (RX) : origin=0x60100000 length=0x400000
    TCMA_RAM   (RW) : origin=0x00000000 length=0x80000
}

SECTIONS {
    .vectors : {} > QSPI_FLASH
    .text    : {} > QSPI_FLASH
    .data    : {} > TCMA_RAM
}
```

**步骤4: 转换为MetaImage**

编译后的.out需要用SDK工具转换：
```bash
buildImage_creator.exe -c APPSS \
    --input_file firmware.out \
    --output_file firmware.appimage
```

### 6.2 实际困难

**困难1: Flash Loader开发**
- 需要深入理解CCS Flash Plugin协议（未公开文档）
- 需要实现QSPI驱动（SDK有源码，但需要适配）
- 调试困难（Flash Loader本身在RAM中运行）

**困难2: MetaImage处理**
- CCS Flash插件不支持MetaImage格式
- 需要额外步骤转换
- 多核同步问题复杂

**困难3: 验证和测试**
- 每次测试需要完整烧录
- 出错后Flash可能损坏
- 恢复成本高

**时间成本估算**：
- Flash Loader开发: 1-2周
- 协议调试: 1周
- 测试验证: 3-5天
- **总计: 3-4周**

vs

- 学习arprog使用: 1小时
- 集成到构建流程: 半天

### 6.3 TI为什么不提供CCS Flash插件

**官方解释**（基于E2E论坛）：

1. **复杂度高**
   - mmWave雷达芯片启动流程复杂
   - 多核同步、MetaImage格式、Flash分区管理

2. **维护成本**
   - 每个SDK版本可能需要更新Flash插件
   - CCS版本兼容性问题

3. **arprog已经足够**
   - 命令行工具更适合自动化
   - 图形界面工具满足手动烧录

4. **避免错误配置**
   - 用户自己配置容易出错
   - 统一的arprog工具保证可靠性

---

## 7. 结论与建议

### 7.1 核心结论

1. **CCS Flash Project在AWRL6844上失败的原因**：
   - ❌ 缺少官方Flash Loader插件
   - ❌ Linker配置的是RAM地址，不是Flash地址
   - ❌ 不支持MetaImage格式
   - ❌ TI未提供AWRL6844的Flash配置

2. **arprog是TI官方标准方案**：
   - ✅ ROM Bootloader内置支持
   - ✅ 支持MetaImage格式
   - ✅ 可靠性经过验证
   - ✅ 命令行易于自动化

3. **理论上可以自己实现CCS Flash**：
   - 🔧 需要开发Flash Loader
   - 🔧 需要配置复杂的XML
   - 🔧 需要3-4周开发时间
   - ⚠️ 投入产出比极低

### 7.2 实践建议

**对于日常开发**：

```
✅ 使用CCS Debug Project
   - RAM执行，快速调试
   - JTAG实时断点
   - 适合功能开发和调试
```

**对于固件烧录**：

```
✅ 使用arprog命令行
   - 快速可靠
   - 易于集成到CI/CD
   - 适合自动化测试

✅ 使用SDK Visualizer
   - 图形界面友好
   - 一键烧录+配置+测试
   - 适合手动验证
```

**不推荐**：

```
❌ 尝试配置CCS Flash
   - 投入产出比低
   - 没有官方支持
   - 容易出错
```

### 7.3 完整工作流程

**推荐的AWRL6844开发流程**：

```
┌────────────────────────┐
│  CCS开发环境           │
│  - 编写代码            │
│  - Debug Project调试   │
│  - RAM执行快速验证     │
└───────────┬────────────┘
            ↓
┌────────────────────────┐
│  CCS编译               │
│  - Project → Build All │
│  - 生成.out文件        │
│  - 生成.appimage       │
└───────────┬────────────┘
            ↓
┌────────────────────────┐
│  arprog烧录            │
│  - 烧录到QSPI Flash    │
│  - 验证完整性          │
└───────────┬────────────┘
            ↓
┌────────────────────────┐
│  断电测试              │
│  - 移除JTAG连接        │
│  - 上电自动运行        │
│  - 串口监控输出        │
└────────────────────────┘
```

### 7.4 快速烧录命令（复制即用）

```powershell
# 基础烧录（不带SBL）
C:\ti\MMWAVE_L_SDK_06_01_00_01\tools\FlashingTool\arprog_cmdline_6844.exe `
  -p COM3 `
  -f1 "C:\Users\Administrator\workspace_ccstheia\demo_in_cabin_sensing_6844_system\Release\demo_in_cabin_sensing_6844_system.release.appimage" `
  -s SFLASH `
  -c

# 完整烧录（SBL + App）
C:\ti\MMWAVE_L_SDK_06_01_00_01\tools\FlashingTool\arprog_cmdline_6844.exe `
  -p COM3 `
  -f1 "C:\ti\MMWAVE_L_SDK_06_01_00_01\examples\drivers\boot\sbl\xwrL684x-evm\r5fss0-0_nortos\ti-arm-clang\sbl.release.appimage" `
  -of1 8192 `
  -f2 "C:\Users\Administrator\workspace_ccstheia\demo_in_cabin_sensing_6844_system\Release\demo_in_cabin_sensing_6844_system.release.appimage" `
  -of2 270336 `
  -s SFLASH `
  -c `
  -cf
```

**参数说明**：
- `-p COM3`: 串口号（根据实际修改）
- `-f1`: 第一个固件（SBL或单独App）
- `-of1`: 第一个固件偏移量
- `-f2`: 第二个固件（App）
- `-of2`: 第二个固件偏移量（0x42000 = 270336）
- `-s SFLASH`: 目标是Serial Flash
- `-c`: 发送Break信号
- `-cf`: 动态创建Flash Header（使用偏移量时必须）

---

## 📚 参考资料

1. **TI官方文档**
   - mmWave L SDK User Guide
   - AWRL6844 Technical Reference Manual
   - Flash Programming Guide

2. **项目文档**
   - `项目文档/4-测试实验结果/1.烧录偏移量实际测试结果.md`
   - `项目文档/3-固件工具/03-固件烧录测试/AWRL6844烧录测试完整报告_2025-12-19.md`
   - `项目文档/3-固件工具/08-AWRL6844雷达健康检测实现方案/AWRL6844雷达健康检测-04-第1章-环境搭建.md`

3. **知识库资源**
   - `知识库/知识库PDF转机器可读文件/AWRL6844-IWRL6844 评估模块.md`
   - `知识库/雷达模块/技术文档/` - 各类技术文档

4. **TI E2E论坛**
   - UniFlash vs arprog讨论
   - AWRL6844烧录常见问题

---

## 🎯 总结一句话

**对于AWRL6844：CCS用来开发调试，arprog用来烧录部署。不要试图用CCS Flash，那是浪费时间。**

---

*本文档由AI助手生成，基于实际项目经验和TI官方文档分析。*
