# TI雷达固件配置文件关系详解

> 📅 日期：2025-12-15
> 📝 主题：SBL、应用固件、配置文件的关联与区别
> 🎯 目的：澄清常见误解，理解完整开发流程

---

## 📋 目录

1. [五个核心文件概览](#五个核心文件概览)
2. [详细解释](#详细解释)
3. [文件关联关系](#文件关联关系)
4. [Flash存储布局](#flash存储布局)
5. [完整工作流程](#完整工作流程)
6. [常见误解澄清](#常见误解澄清)
7. [实际案例](#实际案例)

---

## 🎯 五个核心文件概览

| 文件类型                  | 文件示例          | 使用阶段 | 是否需要烧录 | 说明                     |
| ------------------------- | ----------------- | -------- | ------------ | ------------------------ |
| **🔧 SBL固件**      | `sbl.bin`       | 运行时   | ✅ 必须烧录  | 启动引导程序             |
| **📦 应用固件**     | `demo.bin`      | 运行时   | ✅ 必须烧录  | 主应用程序               |
| **⚙️ .syscfg**    | `mmwave.syscfg` | 编译时   | ❌ 不需要    | 硬件配置（已编译进固件） |
| **⚙️ RTOS .cfg**  | `mmwave.cfg`    | 编译时   | ❌ 不需要    | 系统配置（已编译进固件） |
| **📡 雷达参数.cfg** | `profile.cfg`   | 运行时   | ❌ 串口发送  | 雷达参数配置             |

---

## 📖 详细解释

### 1. 🔧 SBL固件 (Secondary Bootloader)

**文件名示例**：

- `sbl.bin`
- `sbl.release.appimage`
- `sbl_lite.bin`

**作用**：

- 芯片上电后第一个运行的程序
- 从ROM引导程序接手控制
- 初始化Flash和内存系统
- 从Flash加载应用固件到RAM
- 跳转到应用程序执行

**Flash位置**：

- 起始地址：`0x00000000`
- 大小：264KB（0x42000字节）
- 结束地址：`0x00041FFF`

**特点**：

- ✅ 通用程序，可重复使用
- ✅ 不同应用可以共用同一个SBL
- ✅ 从SDK获取，一般不需要修改
- ⚠️ 必须先烧录SBL，再烧录应用

**烧录命令**：

```bash
python flash_tool.py --sbl sbl.bin
```

---

### 2. 📦 应用固件

**文件名示例**：

- `3d_people_tracking.bin`
- `demo_in_cabin_sensing.appimage`
- `mmwave_demo.bin`

**作用**：

- 主要应用程序（用户功能代码）
- 包含所有业务逻辑
- 包含RTOS任务和调度
- 处理雷达数据和算法

**内容组成**：

```
应用固件.bin = 用户代码 + .syscfg生成代码 + RTOS .cfg配置 + 库文件
                ↑              ↑                  ↑             ↑
             main.c等     驱动初始化代码    任务/内存配置   SDK库
```

**Flash位置**：

- 起始地址：`0x00042000`（紧跟SBL之后）
- 大小：剩余Flash空间
- 结束地址：取决于固件大小

**特点**：

- ✅ 每个demo/项目都不同
- ✅ 包含了所有配置（.syscfg + .cfg）
- ✅ 独立的可执行程序
- ⚠️ 必须与对应的SDK版本匹配

**烧录命令**：

```bash
python flash_tool.py --app demo.bin
```

---

### 3. ⚙️ SysConfig配置文件 (.syscfg)

**文件名示例**：

- `mmwave_demo.syscfg`
- `3d_tracking.syscfg`

**使用阶段**：📝 **编译时（开发阶段）**

**工具**：

- CCS SysConfig图形化配置工具
- 基于JavaScript的配置脚本

**配置内容**：

#### 🔌 外设配置

- UART端口（串口通信）
- SPI接口（雷达数据传输）
- I2C总线
- CAN总线
- ADC采样

#### 📍 引脚映射

- GPIO引脚分配
- 复用功能选择
- 上拉/下拉配置
- 输入/输出方向

#### ⏰ 时钟配置

- 系统时钟频率
- 外设时钟分频
- PLL配置

#### 🔄 DMA配置

- DMA通道分配
- 传输优先级
- 触发源配置

**工作流程**：

```
1. 开发者使用CCS打开 .syscfg 文件
   ↓
2. 图形化界面配置外设和引脚
   ↓
3. SysConfig工具自动生成C代码
   ├─ ti_drivers_config.c  （驱动初始化代码）
   ├─ ti_drivers_config.h  （头文件）
   └─ ti_board_config.c    （板级配置）
   ↓
4. 生成的代码被编译进固件
   ↓
5. 最终固件.bin包含这些配置
```

**示例代码**（.syscfg生成）：

```c
// ti_drivers_config.c
void UART_init(void) {
    UART_Params uartParams;
    UART_Params_init(&uartParams);
    uartParams.baudRate = 115200;
    uartParams.dataLength = UART_LEN_8;
    uartParams.parityType = UART_PAR_NONE;
    // ...自动生成的初始化代码
}
```

**关键点**：

- ❌ **运行时不需要此文件**
- ✅ 配置已经转换成C代码并编译进固件
- ✅ 烧录和运行时完全不需要.syscfg文件
- 📁 仅在开发阶段需要（学习、修改配置）

---

### 4. ⚙️ TI-RTOS配置文件 (.cfg)

**文件名示例**：

- `mmwave_demo.cfg`
- `rtos_config.cfg`

**使用阶段**：📝 **编译时（开发阶段）**

**工具**：

- TI-RTOS XDCtools
- 基于JavaScript的配置脚本

**配置内容**：

#### 📋 任务配置

```javascript
var Task = xdc.useModule('ti.sysbios.knl.Task');

// mmwaveTask配置
var mmwaveTaskParams = new Task.Params();
mmwaveTaskParams.instance.name = "mmwaveTask";
mmwaveTaskParams.priority = 5;
mmwaveTaskParams.stackSize = 8192;  // 8KB堆栈

// dataPathTask配置
var dataPathTaskParams = new Task.Params();
dataPathTaskParams.instance.name = "dataPathTask";
dataPathTaskParams.priority = 3;
dataPathTaskParams.stackSize = 16384;  // 16KB堆栈
```

#### 💾 内存配置

```javascript
var HeapMem = xdc.useModule('ti.sysbios.heaps.HeapMem');
var heapMemParams = new HeapMem.Params();
heapMemParams.size = 262144;  // 256KB系统堆
```

#### ⚡ 中断配置

```javascript
var Hwi = xdc.useModule('ti.sysbios.family.arm.m4.Hwi');
Hwi.enableException = true;
Hwi.nvicCCR.STKALIGN = 1;
```

#### 🕐 定时器配置

```javascript
var Clock = xdc.useModule('ti.sysbios.knl.Clock');
Clock.tickPeriod = 1000;  // 1ms滴答周期
```

#### 🔒 信号量配置

```javascript
var Semaphore = xdc.useModule('ti.sysbios.knl.Semaphore');
```

**工作流程**：

```
1. 开发者编辑 .cfg 文件
   ↓
2. CCS调用XDCtools处理.cfg
   ↓
3. XDCtools生成C代码
   ├─ 任务创建代码
   ├─ 内存分配代码
   ├─ 中断向量表
   └─ RTOS内核配置
   ↓
4. 编译器将生成的代码编译进固件
   ↓
5. 最终固件.bin包含完整的RTOS配置
```

**运行时效果**：

```c
// 固件启动时自动执行（由.cfg生成）
void main(void) {
    // .syscfg生成的硬件初始化
    Board_init();
  
    // .cfg生成的RTOS启动
    BIOS_start();  // 永不返回
  
    // BIOS_start()会：
    // 1. 创建.cfg中定义的所有任务
    // 2. 分配.cfg中配置的内存
    // 3. 启动任务调度器
    // 4. 开始运行最高优先级任务
}
```

**关键点**：

- ❌ **运行时不需要此文件**
- ✅ 配置已经转换成C代码并编译进固件
- ✅ RTOS内核和任务配置已经"烧"进固件
- 📁 仅在开发阶段需要（学习、修改RTOS配置）

---

### 5. 📡 雷达参数配置文件 (.cfg)

**文件名示例**：

- `profile.cfg`
- `chirp_config.cfg`
- `sensor_config.cfg`

**⚠️ 注意**：这个.cfg与前面的RTOS .cfg完全不同！

**使用阶段**：🚀 **运行时（应用阶段）**

**配置内容**：

#### 🎯 Chirp配置

```
profileCfg 0 77 7 7 200 0 0 70 1 256 5209
参数说明：
  - 起始频率：77 GHz
  - 带宽：7 GHz
  - 斜率：200 MHz/μs
  - ADC采样点：256
```

#### 📏 帧配置

```
frameCfg 0 0 32 0 100 1 0
参数说明：
  - chirp数量：32
  - 帧周期：100ms
  - 触发模式：软件触发
```

#### 📊 数据路径配置

```
adcCfg 2 1
dataFmt 1
```

#### 🔧 其他配置

```
sensorStart    # 启动雷达
sensorStop     # 停止雷达
```

**使用方式**：

**方式1：通过串口手动发送**

```python
# Python示例
import serial

ser = serial.Serial('COM3', 115200)
ser.write(b'sensorStart\n')
ser.write(b'profileCfg 0 77 7 7 200 0 0 70 1 256 5209\n')
ser.write(b'chirpCfg 0 0 0 0 0 0 0 1\n')
ser.write(b'frameCfg 0 0 32 0 100 1 0\n')
```

**方式2：读取.cfg文件发送**

```python
# Python示例
with open('profile.cfg', 'r') as f:
    for line in f:
        line = line.strip()
        if line and not line.startswith('#'):
            ser.write(line.encode() + b'\n')
            time.sleep(0.1)
```

**方式3：固件内置默认配置**

```c
// C代码示例（固件中）
void initRadarConfig(void) {
    // 发送预设的雷达配置
    sendCommand("profileCfg 0 77 7 7 200 0 0 70 1 256 5209");
    sendCommand("chirpCfg 0 0 0 0 0 0 0 1");
    sendCommand("frameCfg 0 0 32 0 100 1 0");
    sendCommand("sensorStart");
}
```

**关键点**：

- ✅ **运行时配置**，通过串口CLI发送
- ✅ 可以在固件运行时动态修改
- ✅ 不同应用场景可以使用不同配置
- ❌ 不需要烧录，只需串口通信
- 📁 配置文件是纯文本，可以自己编写

**配置时机**：

```
固件启动 → 等待配置 → 收到雷达配置命令 → 雷达开始工作
            ↑
        通过串口发送profile.cfg中的命令
```

---

## 🔗 文件关联关系

### 时间线视图

```
[开发阶段] ─────────────────────────────────────────────────
│
├─ 1️⃣ 编写用户代码
│   ├─ main.c
│   ├─ mmwave_processing.c
│   └─ algorithm.c
│
├─ 2️⃣ 配置硬件 (.syscfg)
│   ├─ 使用CCS SysConfig工具
│   ├─ 配置UART、SPI、GPIO等
│   └─ 自动生成ti_drivers_config.c
│
├─ 3️⃣ 配置RTOS (.cfg)
│   ├─ 编辑mmwave_demo.cfg
│   ├─ 定义任务、内存、中断
│   └─ XDCtools生成RTOS配置代码
│
├─ 4️⃣ CCS编译
│   ├─ 用户代码
│   ├─ .syscfg生成的代码
│   ├─ .cfg生成的代码
│   └─ SDK库文件
│   ↓
│   输出: demo.bin (包含所有配置)
│
└─────────────────────────────────────────────────────────


[烧录阶段] ─────────────────────────────────────────────────
│
├─ 5️⃣ 烧录SBL
│   └─ python flash_tool.py --sbl sbl.bin
│       → Flash 0x0 - 0x42000
│
├─ 6️⃣ 烧录应用固件
│   └─ python flash_tool.py --app demo.bin
│       → Flash 0x42000 - 结束
│
└─────────────────────────────────────────────────────────


[运行阶段] ─────────────────────────────────────────────────
│
├─ 7️⃣ 上电启动
│   ├─ ROM引导 → SBL
│   ├─ SBL → 加载应用固件到RAM
│   └─ 跳转到应用main()
│
├─ 8️⃣ 固件初始化
│   ├─ Board_init()
│   │   └─ .syscfg配置的硬件初始化
│   └─ BIOS_start()
│       └─ .cfg配置的RTOS启动
│
├─ 9️⃣ RTOS运行
│   ├─ 任务调度开始
│   ├─ mmwaveTask运行
│   └─ dataPathTask运行
│
├─ 🔟 (可选) 配置雷达参数
│   ├─ 通过串口发送命令
│   ├─ 读取profile.cfg文件
│   └─ 或使用固件内置默认配置
│
└─ 1️⃣1️⃣ 雷达开始工作
    └─ 采集、处理、输出数据
```

### 依赖关系图

```
┌─────────────────────────────────────────────────────────┐
│                    开发阶段                             │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐             │
│  │用户代码  │  │.syscfg   │  │RTOS .cfg │             │
│  │main.c等  │  │硬件配置  │  │系统配置  │             │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘             │
│       │             │              │                    │
│       └─────────────┴──────────────┘                    │
│                     │                                   │
│                 CCS编译器                               │
│                     │                                   │
│                     ↓                                   │
│            ┌─────────────────┐                         │
│            │  应用固件.bin   │                         │
│            │ (包含所有配置)  │                         │
│            └────────┬────────┘                         │
└─────────────────────┼──────────────────────────────────┘
                      │
┌─────────────────────┼──────────────────────────────────┐
│                 烧录阶段                                │
│                     ↓                                   │
│         ┌───────────────────────┐                      │
│         │   Flash存储器         │                      │
│         ├───────────────────────┤                      │
│         │ 0x0: SBL.bin          │ ← 从SDK获取          │
│         ├───────────────────────┤                      │
│         │ 0x42000: 应用固件.bin │ ← 编译生成           │
│         └───────────────────────┘                      │
└─────────────────────────────────┼──────────────────────┘
                      │
┌─────────────────────┼──────────────────────────────────┐
│                 运行阶段                                │
│                     ↓                                   │
│             上电 → SBL → 应用                          │
│                     ↓                                   │
│         ┌───────────────────────┐                      │
│         │   RTOS运行            │                      │
│         │ (.cfg配置已生效)      │                      │
│         └───────────┬───────────┘                      │
│                     │                                   │
│                     ↓                                   │
│         ┌───────────────────────┐                      │
│         │   硬件驱动工作        │                      │
│         │ (.syscfg配置已生效)   │                      │
│         └───────────┬───────────┘                      │
│                     │                                   │
│                     ↓                                   │
│         (可选) 通过串口发送                            │
│         ┌───────────────────────┐                      │
│         │ 雷达参数.cfg命令      │                      │
│         └───────────┬───────────┘                      │
│                     ↓                                   │
│                雷达开始工作                            │
└─────────────────────────────────────────────────────────┘
```

---

## 💾 Flash存储布局

### AWRL6844EVM Flash地图

```
┌─────────────────────────────────────────────────────────┐
│  Flash地址范围          │ 内容          │ 大小        │
├─────────────────────────┼───────────────┼─────────────┤
│  0x00000000 - 0x00001FFF│ 保留区域      │ 8 KB        │
│  0x00002000 - 0x00041FFF│ 🔧 SBL固件    │ 256 KB      │
│  0x00042000 - 0x001FFFFF│ 📦 应用固件   │ ~1.74 MB    │
│                          │ (包含所有配置)│             │
└─────────────────────────┴───────────────┴─────────────┘
         ↑                       ↑              ↑
      起始地址              SBL结束        Flash结束
                          应用起始
```

### 详细说明

**保留区域 (0x0 - 0x2000)**

- ROM引导代码使用
- 不可烧录

**SBL区域 (0x2000 - 0x42000)**

- 大小：256KB (0x40000字节)
- 内容：SBL引导程序
- 烧录：第一次或SBL更新时
- 特点：通用程序，不常更新

**应用固件区域 (0x42000 - 0x200000)**

- 大小：~1.74MB
- 内容：
  ```
  ┌────────────────────────┐
  │ 应用代码段             │
  ├────────────────────────┤
  │ 数据段                 │
  ├────────────────────────┤
  │ .syscfg生成的驱动代码  │
  ├────────────────────────┤
  │ RTOS .cfg配置代码      │
  ├────────────────────────┤
  │ SDK库代码              │
  ├────────────────────────┤
  │ 常量数据               │
  └────────────────────────┘
  ```
- 烧录：每次应用更新时
- 特点：包含所有配置，独立可执行

---

## 🔄 完整工作流程

### 场景A：使用SDK预编译Demo

**步骤1：准备文件**

```
从SDK获取：
  ├─ sbl.bin                    (SBL引导)
  └─ demo_3d_tracking.bin       (预编译应用)
```

**步骤2：烧录固件**

```bash
# 烧录SBL
python flash_tool.py --sbl sbl.bin

# 烧录应用
python flash_tool.py --app demo_3d_tracking.bin
```

**步骤3：上电运行**

```
1. 连接开发板电源
2. ROM → SBL → 应用
3. 固件自动运行
4. UART输出启动信息
```

**步骤4：(可选) 配置雷达**

```bash
# 通过串口发送配置命令
python serial_cli.py --port COM3 --config profile.cfg
```

**✅ 关键点**：

- 不需要.syscfg文件
- 不需要RTOS .cfg文件
- 这些配置已经在demo.bin中了

---

### 场景B：自己开发固件

**步骤1：创建CCS项目**

```
1. File → New → CCS Project
2. 选择AWRL6844设备
3. 选择TI-RTOS模板
```

**步骤2：配置硬件 (.syscfg)**

```
1. 双击项目中的 .syscfg 文件
2. 图形化配置：
   - UART: 115200波特率
   - SPI: 雷达数据接口
   - GPIO: LED控制
3. 保存，自动生成驱动代码
```

**步骤3：配置RTOS (.cfg)**

```javascript
// mmwave_demo.cfg
var Task = xdc.useModule('ti.sysbios.knl.Task');

// 主任务
var mainTaskParams = new Task.Params();
mainTaskParams.instance.name = "mainTask";
mainTaskParams.priority = 5;
mainTaskParams.stackSize = 8192;
Task.create('&mainTaskFxn', mainTaskParams);

// 数据处理任务
var dataTaskParams = new Task.Params();
dataTaskParams.instance.name = "dataTask";
dataTaskParams.priority = 3;
dataTaskParams.stackSize = 16384;
Task.create('&dataTaskFxn', dataTaskParams);
```

**步骤4：编写应用代码**

```c
// main.c
#include "ti_drivers_config.h"  // .syscfg生成

void mainTaskFxn(UArg arg0, UArg arg1) {
    // 使用.syscfg配置的UART
    UART_Handle uart = UART_open(0, NULL);
  
    while(1) {
        // 应用逻辑
        Task_sleep(100);
    }
}

void main(void) {
    // .syscfg生成的初始化
    Board_init();
  
    // .cfg配置的RTOS启动
    BIOS_start();  // 创建任务并开始调度
}
```

**步骤5：编译生成固件**

```
1. Project → Build Project
2. 输出：Debug/myapp.bin
```

**步骤6：烧录测试**

```bash
# 烧录SBL
python flash_tool.py --sbl sbl.bin

# 烧录自己的应用
python flash_tool.py --app myapp.bin
```

**步骤7：调试和配置**

```
1. 上电运行
2. 通过串口发送雷达配置：
   sensorStart
   profileCfg ...
   chirpCfg ...
3. 观察UART输出
4. 调试和优化
```

---

### 场景C：学习现有Demo配置

**目的**：了解SDK demo是如何配置的

**步骤1：使用固件库功能**

```
1. 打开烧录工具固件库标签页
2. 找到感兴趣的demo：
   📦 3D_People_Tracking [radar_toolbox]
```

**步骤2：查看固件信息**

```
固件详情显示：
  📦 固件文件
     文件名: 3d_people_tracking.bin
     路径: C:\ti\radar_toolbox\...\prebuilt_binaries\
  
  ⚙️ SysConfig配置文件 (.syscfg)
     ✅ 已找到
     路径: C:\ti\radar_toolbox\...\mmwave_demo.syscfg
     用途: 配置UART、SPI、GPIO等外设
  
  ⚙️ RTOS配置文件 (.cfg)
     ✅ 已找到
     路径: C:\ti\radar_toolbox\...\mmwave_demo.cfg
     用途: 配置任务、内存、中断
```

**步骤3：打开配置文件学习**

```bash
# 使用CCS打开.syscfg
1. File → Open File
2. 选择 mmwave_demo.syscfg
3. 图形化界面查看配置

# 使用文本编辑器打开.cfg
notepad C:\ti\radar_toolbox\...\mmwave_demo.cfg
```

**步骤4：参考配置开发**

```
1. 复制配置到自己的项目
2. 根据需求修改
3. 编译测试
```

---

## ⚠️ 常见误解澄清

### 误解1：需要加载.cfg文件，雷达才会启动

**❌ 错误**：

- "烧录固件后，还要通过某种方式加载.cfg文件"
- "需要用工具把.cfg发送给雷达"

**✅ 正确**：

- TI-RTOS的.cfg是**编译时配置**
- 配置已经编译进.bin固件
- 烧录固件后，配置已经在芯片中
- 上电自动运行，不需要任何.cfg文件

**原理**：

```
编译时：
  .cfg → XDCtools → C代码 → 编译 → .bin固件

运行时：
  上电 → SBL → 加载.bin → RTOS启动（配置已生效）
```

---

### 误解2：混淆两种.cfg文件

**问题**：TI系统中有两种.cfg文件，容易混淆

#### 📄 类型1：TI-RTOS配置文件 (.cfg)

- **位置**：CCS项目源代码目录
- **语法**：JavaScript
- **时机**：编译时
- **示例**：
  ```javascript
  var Task = xdc.useModule('ti.sysbios.knl.Task');
  Task.defaultStackSize = 8192;
  ```
- **作用**：配置RTOS内核（编译进固件）
- **运行时**：❌ 不需要

#### 📄 类型2：雷达参数配置文件 (.cfg)

- **位置**：独立配置文件
- **语法**：纯文本命令
- **时机**：运行时
- **示例**：
  ```
  sensorStart
  profileCfg 0 77 7 7 200 0 0 70 1 256 5209
  chirpCfg 0 0 0 0 0 0 0 1
  ```
- **作用**：配置雷达参数（串口发送）
- **运行时**：✅ 通过串口发送

**区分方法**：

| 特征       | RTOS .cfg   | 雷达参数.cfg |
| ---------- | ----------- | ------------ |
| 文件扩展名 | .cfg        | .cfg         |
| 文件位置   | 项目源代码  | 独立文件     |
| 内容语法   | JavaScript  | 纯文本命令   |
| 使用时机   | 编译时      | 运行时       |
| 使用方式   | CCS自动处理 | 串口发送     |
| 是否烧录   | 编译进固件  | 不烧录       |

---

### 误解3：.syscfg需要单独烧录

**❌ 错误**：

- "需要把.syscfg文件也烧录到Flash"
- "固件和配置要分开烧录"

**✅ 正确**：

- .syscfg是**编译时工具**
- 生成的C代码被编译进.bin固件
- 只需要烧录.bin文件
- 配置已经在固件中了

**验证方法**：

```bash
# 查看固件大小
ls -lh demo.bin
# 输出: 512KB  ← 包含了所有配置代码

# 反汇编查看（可以看到.syscfg生成的驱动代码）
arm-none-eabi-objdump -d demo.bin | grep "UART_init"
```

---

### 误解4：SBL每次都要重新烧录

**❌ 不必要**：

- 每次烧录应用时都重新烧录SBL

**✅ 正确做法**：

- SBL是通用引导程序
- 只需烧录一次（或SBL更新时）
- 之后只烧录应用固件即可

**原因**：

```
Flash布局：
  0x0:      SBL（通用，不变）
  0x42000:  应用（经常变化）

更新应用时：
  只需要重新烧录0x42000之后的区域
  SBL区域不受影响
```

**最佳实践**：

```bash
# 首次烧录（或SDK升级后）
python flash_tool.py --sbl sbl.bin --app myapp.bin

# 后续只更新应用
python flash_tool.py --app myapp_v2.bin
```

---

### 误解5：配置文件是可选的

**❌ 错误**：

- "不用.syscfg也可以开发"
- ".cfg可以不配置"

**✅ 事实**：

- **可以不用工具**，但配置仍然需要
- 不用.syscfg → 手写驱动初始化代码
- 不用.cfg → 手写RTOS配置代码

**对比**：

```
使用配置工具：
  .syscfg配置 → 自动生成100行驱动代码
  .cfg配置 → 自动生成RTOS配置

不使用工具：
  需要手写100行驱动初始化代码
  需要手写RTOS配置和任务创建代码
```

**结论**：

- 配置是**必须的**
- 工具只是**简化配置过程**
- 推荐使用工具，提高开发效率

---

## 📚 实际案例

### 案例1：3D人员追踪Demo

**项目文件结构**：

```
AWRL6844_3D_People_Tracking/
├─ 📄 mmwave_demo.syscfg          # 硬件配置
├─ 📄 mmwave_demo.cfg              # RTOS配置
├─ 📁 src/
│  ├─ main.c                       # 主程序
│  ├─ mmwave_processing.c          # 雷达处理
│  └─ tracking_algorithm.c         # 追踪算法
├─ 📁 ti_drivers_config/          # .syscfg生成
│  ├─ ti_drivers_config.c
│  └─ ti_drivers_config.h
└─ 📁 Debug/
   └─ 3d_people_tracking.bin      # 编译输出
```

**mmwave_demo.syscfg配置**：

```
外设配置：
  ✅ UART0: 115200波特率，用于日志输出
  ✅ UART1: 921600波特率，用于数据输出
  ✅ SPI0: 雷达数据接口
  ✅ GPIO: LED状态指示
  ✅ DMA: 数据传输加速
  ✅ 时钟: 200MHz系统时钟
```

**mmwave_demo.cfg配置**：

```javascript
任务配置：
  ✅ mmwaveTask: 优先级5, 堆栈8KB
     - 处理雷达命令
     - 控制雷达工作
  
  ✅ dataPathTask: 优先级3, 堆栈16KB
     - FFT处理
     - 目标检测
  
  ✅ trackingTask: 优先级2, 堆栈12KB
     - 3D追踪算法
     - 轨迹预测

内存配置：
  ✅ 系统堆: 256KB
  ✅ L3 RAM: 512KB（雷达数据缓冲）
```

**编译和烧录**：

```bash
# CCS编译
Project → Build Project
输出: Debug/3d_people_tracking.bin (478KB)

# 烧录
python flash_tool.py --sbl sbl.bin
python flash_tool.py --app 3d_people_tracking.bin
```

**运行和配置**：

```
1. 上电启动
   ROM → SBL → 应用固件

2. 固件初始化
   - Board_init()（.syscfg配置）
   - BIOS_start()（.cfg配置）
   - 创建3个任务

3. 等待雷达配置（可选）
   如果需要自定义参数，通过串口发送：
   
   sensorStart
   profileCfg 0 77 7 7 200 0 0 70 1 256 5209
   chirpCfg 0 0 0 0 0 0 0 1
   frameCfg 0 0 32 0 100 1 0

4. 雷达开始工作
   - 采集数据
   - 3D追踪
   - UART输出追踪结果
```

**关键数据流**：

```
雷达前端 → SPI → DMA → L3 RAM
    ↓
数据处理任务（FFT、CFAR）
    ↓
追踪任务（3D算法）
    ↓
UART输出（点云+追踪结果）
```

---

### 案例2：车内检测Demo

**配置重点**：

**mmwave_demo.syscfg**：

```
特殊配置：
  ✅ UART: 高速数据输出（921600）
  ✅ CAN: 车载网络接口
  ✅ GPIO: 多个LED指示不同状态
     - LED1: 系统运行
     - LED2: 检测到人员
     - LED3: 检测到儿童
```

**mmwave_demo.cfg**：

```javascript
特殊配置：
  ✅ 高优先级数据处理
  ✅ 实时性要求高
  ✅ CAN通信任务
```

**雷达参数.cfg**（运行时）：

```
车内检测优化配置：
  profileCfg 0 60 7 7 100 0 0 50 1 256 3000
  # 60GHz起始频率，适合近距离检测
  # 较窄带宽，精确测距
  # 优化的chirp参数
```

---

### 案例3：最小系统（Hello World）

**极简配置示例**：

**mmwave_demo.syscfg**：

```
最小配置：
  ✅ UART0: 仅用于printf输出
  ✅ GPIO: 一个LED闪烁
  ✅ 基础时钟配置
```

**mmwave_demo.cfg**：

```javascript
最小RTOS配置：
  var Task = xdc.useModule('ti.sysbios.knl.Task');
  var blinkTaskParams = new Task.Params();
  blinkTaskParams.stackSize = 1024;  // 最小堆栈
  Task.create('&blinkLed', blinkTaskParams);
```

**main.c**：

```c
#include "ti_drivers_config.h"

void blinkLed(UArg arg0, UArg arg1) {
    GPIO_init();
  
    while(1) {
        GPIO_toggle(LED0);
        Task_sleep(1000);  // 1秒
    }
}

void main(void) {
    Board_init();   // .syscfg生成的初始化
    BIOS_start();   // .cfg配置的RTOS
}
```

**编译输出**：

```
hello_world.bin: 128KB
  ├─ 用户代码: 2KB
  ├─ .syscfg驱动: 15KB
  ├─ .cfg RTOS配置: 8KB
  └─ SDK库: 103KB
```

**烧录和运行**：

```bash
python flash_tool.py --sbl sbl.bin --app hello_world.bin

# 上电后：LED每秒闪烁一次
# 完全不需要雷达配置
```

---

## 🎯 总结速查表

### 烧录需要的文件

| 文件                | 必须 | 用途           | 来源       |
| ------------------- | ---- | -------------- | ---------- |
| **SBL.bin**   | ✅   | 引导程序       | SDK提供    |
| **应用.bin**  | ✅   | 主程序         | 编译生成   |
| **.syscfg**   | ❌   | 已编译进固件   | 开发时需要 |
| **RTOS .cfg** | ❌   | 已编译进固件   | 开发时需要 |
| **雷达.cfg**  | ❌   | 运行时串口发送 | 可选配置   |

### 各阶段需要的文件

| 阶段           | 需要的文件                     |
| -------------- | ------------------------------ |
| **开发** | 用户代码 + .syscfg + RTOS .cfg |
| **编译** | CCS自动处理所有配置            |
| **烧录** | SBL.bin + 应用.bin             |
| **运行** | 无需外部文件（可选雷达配置）   |

### 常见操作命令

```bash
# 完整烧录（首次或更新SBL）
python flash_tool.py --sbl sbl.bin --app demo.bin

# 只更新应用（常规开发）
python flash_tool.py --app demo.bin

# 串口配置雷达（可选）
python serial_cli.py --port COM3 --config profile.cfg
```

---

## 📖 参考资源

### TI官方文档

1. **MMWAVE-L SDK用户指南**

   - 路径：`C:\ti\MMWAVE_L_SDK_06_01_00_01\docs\`
   - 包含：SDK结构、API说明、示例代码
2. **SysConfig用户指南**

   - CCS集成工具
   - 图形化配置界面
   - 自动代码生成
3. **TI-RTOS用户指南**

   - RTOS内核文档
   - .cfg配置语法
   - 任务调度机制

### 本地参考

1. **知识库文档**

   - 路径：`项目文档/知识库/`
   - 包含：PDF转Markdown技术文档
2. **固件库示例**

   - 使用烧录工具的固件库功能
   - 查看各demo的配置文件
   - 学习最佳实践
3. **开发记录**

   - 路径：`项目文档/2-开发记录/`
   - 包含：问题解决、配置经验

---

## ✅ 快速检查清单

### 开发新固件前

- [ ] 确认使用的SDK版本
- [ ] 准备好SBL.bin（从SDK获取）
- [ ] 创建CCS项目
- [ ] 配置.syscfg（硬件）
- [ ] 配置.cfg（RTOS）
- [ ] 编写应用代码

### 编译前检查

- [ ] .syscfg配置已保存
- [ ] .cfg语法正确
- [ ] 用户代码无编译错误
- [ ] SDK路径配置正确

### 烧录前检查

- [ ] 生成了.bin固件文件
- [ ] SBL.bin准备好（首次需要）
- [ ] 串口连接正确（COM口、波特率）
- [ ] 开发板供电正常

### 运行时检查

- [ ] 上电后LED闪烁（正常启动）
- [ ] UART输出启动信息
- [ ] （可选）发送雷达配置命令
- [ ] 观察雷达数据输出

---

## 🔍 故障排查

### 问题1：固件烧录后不运行

**可能原因**：

1. SBL未烧录或损坏
2. 应用固件起始地址错误
3. Flash擦除不完整

**解决方法**：

```bash
# 重新烧录SBL和应用
python flash_tool.py --erase
python flash_tool.py --sbl sbl.bin
python flash_tool.py --app demo.bin
```

---

### 问题2：编译时.syscfg错误

**可能原因**：

1. SysConfig版本不匹配
2. 引脚配置冲突
3. 外设配置错误

**解决方法**：

```
1. 检查CCS和SDK版本匹配
2. 打开.syscfg检查错误提示
3. 参考SDK示例的配置
```

---

### 问题3：RTOS启动失败

**可能原因**：

1. .cfg语法错误
2. 堆栈大小不足
3. 内存分配错误

**解决方法**：

```javascript
// 增加堆栈大小
Task.defaultStackSize = 8192;  // 改为16384

// 增加系统堆
var HeapMem = xdc.useModule('ti.sysbios.heaps.HeapMem');
heapMemParams.size = 262144;  // 256KB
```

---

## 📝 版本历史

| 版本 | 日期       | 修改内容                       |
| ---- | ---------- | ------------------------------ |
| v1.0 | 2025-12-15 | 初始版本，完整说明五个文件关系 |

---

> 💡 **关键要点**：
>
> - SBL和应用固件需要烧录到Flash
> - .syscfg和RTOS .cfg是编译时工具，配置已编译进固件
> - 雷达参数.cfg是运行时配置，通过串口发送
> - 烧录只需要两个.bin文件：SBL + 应用固件

---

**文档作者**：Benson@Wisefido
**项目**：AWRL6844EVM 姿态检测雷达
**工具**：Python烧录工具 v1.1.3
