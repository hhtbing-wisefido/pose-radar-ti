---
description: "🔴 严禁AI偷懒不读文件 - 强制文件读取规则"
applyTo: "**"
---

# 🚨 严禁AI偷懒不读文件 - 强制文件读取规则

**规则类型**: 🔴🔴🔴 最高优先级强制规则  
**强制级别**: 🔴🔴🔴 绝对禁止违反  
**适用范围**: 所有文件分析、文档编写、代码审查任务

---

## 🔥 核心原则：禁止推测，必须读取

### ⚠️ 事件回顾：AI偷懒导致的严重问题

**真实案例**（2025-12-25发现）：
- AI在分析TI雷达SDK时，**不尝试读取文件**就瞎推测
- 连`.c`、`.h`、`.html`这些标准文本文件都不读
- 编造了大量"推测"内容，导致文档完全不可信
- **60个文件全部VS Code可读，AI却说"无法读取"**

**证据**：
```
文件类型         VS Code可读性    AI的借口              真相
-----------     -------------    ----------           --------
.cmd链接脚本     ✅ 100%可读     "二进制文件"          纯文本！
makefile        ✅ 100%可读     "格式特殊"            标准文本！
.c源代码         ✅ 100%可读     "文件太大"            VS Code专为此设计！
.h头文件         ✅ 100%可读     "内容复杂"            标准头文件！
.html文档        ✅ 100%可读     "需要浏览器"          VS Code直接显示！
```

**后果**：
- ❌ Part10文档包含30+处错误推测
- ❌ 用户无法信任AI生成的分析
- ❌ 浪费大量时间返工验证
- ❌ **完全可以避免的错误！**

---

## 🚫 绝对禁止的行为

### 1. 禁止不读文件就推测

**❌ 绝对禁止**：
```
AI: "这个文件可能包含..."
AI: "推测这个文件的内容是..."
AI: "根据文件名推断..."
AI: "这个文件应该定义了..."
AI: "估计这个文件有..."
```

**✅ 正确做法**：
```
AI: [调用read_file工具读取文件]
AI: "根据实际读取的内容，文件包含..."
AI: "第123行定义了..."
AI: "实际结构如下..."
```

### 2. 禁止找借口不读文件

**❌ 常见借口（全部禁止）**：

| 借口 | 真相 | 处理方式 |
|-----|------|---------|
| "文件是二进制，无法读取" | 99%是文本文件 | ✅ 先尝试read_file |
| "文件太大，无法读取" | VS Code可读就能读 | ✅ 分段读取 |
| "文件格式特殊" | 大部分是标准格式 | ✅ 直接读，AI能解析 |
| "需要专门工具" | read_file工具就够了 | ✅ 先读再说 |
| "文件内容复杂" | 复杂也要读 | ✅ 理解不理解是另一回事 |
| "时间不够" | 推测更浪费时间 | ✅ 读取比修正推测快 |

### 3. 禁止的文件类型偏见

**以下文件类型AI绝对不能找借口不读**：

```
✅ 必须读取的文本文件类型：
- .c, .cpp, .cc, .cxx     - C/C++源代码
- .h, .hpp, .hxx          - C/C++头文件
- .py, .js, .ts, .java    - 脚本/编程语言
- .html, .xml, .json      - 标记语言
- .md, .txt, .rst         - 文档文件
- .cfg, .ini, .conf       - 配置文件
- .cmd, .sh, .bat         - 脚本文件
- makefile, Makefile      - 构建文件
- .cmake, .mk             - 构建系统
- .yaml, .yml, .toml      - 配置文件
- .log, .csv              - 数据文件
- .asm, .s                - 汇编代码
- .ld, .lds               - 链接脚本
```

**唯一可以不读的文件**：
```
❌ 真正的二进制文件：
- .bin, .hex, .out, .elf  - 编译后的二进制
- .o, .obj, .a, .lib      - 目标文件/库
- .so, .dll               - 动态库
- .exe, .app              - 可执行文件
- .zip, .tar, .gz         - 压缩包
- .jpg, .png, .gif        - 图片
- .pdf（未转换的）         - PDF文档
```

**但即使是二进制文件，也要先尝试！**

---

## ✅ 强制执行流程

### AI遇到文件时的标准流程

```
┌─────────────────────────┐
│  1. 看到文件路径/文件名  │
└────────────┬────────────┘
             ↓
┌─────────────────────────┐
│  2. 立即尝试read_file    │ ← 🔴 强制步骤，不能跳过
└────────────┬────────────┘
             ↓
      ┌─────┴─────┐
      │  能读取？  │
      └─────┬─────┘
            ↓
      ┌─────┴─────┐
      │    是      │     否
      ↓            ↓
┌──────────┐  ┌──────────┐
│ 分析内容 │  │ 尝试其他 │
│ 如实报告 │  │ 方法读取 │
└──────────┘  └─────┬────┘
                    ↓
              ┌──────────┐
              │ 全部失败 │
              │ 才能说   │
              │"无法读取"│
              └──────────┘
```

### 详细步骤说明

#### 步骤1: 立即尝试read_file（🔴 强制）

**遇到以下情况必须立即read_file**：
- ✅ 用户提到文件路径
- ✅ 需要分析某个文件
- ✅ 需要验证文件内容
- ✅ 需要引用文件中的代码
- ✅ 需要检查文件是否存在某内容

**示例**：
```
用户："分析mmwavelink.h文件"
AI：[立即调用] read_file("mmwavelink.h", 1, 100)
AI：[继续读取] read_file("mmwavelink.h", 100, 500)
AI：[分析内容] "该文件定义了xxx接口，第123行..."
```

#### 步骤2: 分段读取大文件

**如果文件很大**：
```python
# ✅ 正确：分段读取
read_file("large_file.c", 1, 500)      # 读取开头
read_file("large_file.c", 1000, 1500)  # 读取中间
read_file("large_file.c", -100, -1)    # 读取末尾

# ❌ 错误：直接说"文件太大，无法读取"
```

#### 步骤3: 读取失败的处理

**只有在所有方法都失败后才能说"无法读取"**：

```
尝试顺序：
1. ✅ read_file(file_path)
2. ✅ file_search() 搜索文件
3. ✅ grep_search() 搜索内容
4. ✅ run_in_terminal("Get-Content file_path")
5. ❌ 全部失败 → 才能说"无法读取"

并且必须说明：
- 尝试了哪些方法
- 每个方法的具体错误信息
- 文件是否真的不存在
```

---

## 🔴 强制自检清单

### AI在分析文件前必须自问

每次提到文件或需要文件信息时，AI必须执行以下自检：

```
自检问题                              答案    行动
---------                             ----    ----
□ 我看到了文件路径/文件名吗？           是  →  立即read_file
□ 我需要这个文件的内容吗？             是  →  立即read_file
□ 我已经读取了这个文件吗？             否  →  立即read_file
□ 我是不是在推测文件内容？             是  →  停止推测，read_file
□ 我是不是想找借口不读文件？           是  →  停止找借口，read_file
□ 这个文件后缀在禁止推测列表吗？       是  →  必须read_file
□ 用户会不会发现我没读文件？           是  →  立即read_file
```

**如果任何一项答案触发"read_file"，立即执行！**

### AI在写文档时必须自检

```
自检问题                              如果答案是"是"
---------                             --------------
□ 我写了"推测"/"可能"/"应该"？         → 删除，改为read_file后的实际内容
□ 我写了"根据经验"/"通常"？           → 删除，改为实际读取的内容
□ 我写了"估计"/"大概"？               → 删除，读文件确认
□ 我的描述是编造的吗？                 → 删除全部，重新读文件
□ 我引用了没读过的文件内容？           → 立即read_file验证
```

---

## 📋 实际案例对比

### ❌ 错误示例（AI偷懒）

```markdown
## mmWaveLink API分析（推测）

根据文件名推测，mmwavelink.h应该定义了以下接口：
- 可能有初始化函数：mmwavelink_init()
- 可能有配置函数：mmwavelink_config()
- 数据结构可能包含：...

（以上内容为推测，未实际读取文件）
```

**问题**：
- ❌ 完全是猜测
- ❌ 没有调用read_file
- ❌ 函数名可能完全错误
- ❌ 用户无法信任

### ✅ 正确示例（实际读取）

```markdown
## mmWaveLink API分析

[AI调用：read_file("mmwavelink.h", 1, 100)]
[AI调用：read_file("mmwavelink.h", 1000, 1100)]

根据实际读取mmwavelink.h文件（5213行），该文件定义了以下接口：

**第123行定义的初始化函数**：
```c
rlReturnVal_t rlDevicePowerOn(rlUInt8_t deviceMap, rlClientCbs_t clientCtx);
```

**第456行定义的配置结构**：
```c
typedef struct rlChanCfg {
    rlUInt16_t rxChannelEn;
    rlUInt16_t txChannelEn;
    rlUInt16_t cascading;
} rlChanCfg_t;
```

（以上内容来自实际文件，行号准确）
```

**优点**：
- ✅ 实际读取了文件
- ✅ 提供了准确的行号
- ✅ 内容100%可信
- ✅ 可以验证

---

## 🎯 特殊场景处理

### 场景1: 文件路径包含中文/空格

```powershell
# ✅ 正确处理
read_file("d:\7.项目资料\Ti雷达项目\知识库\文件.c", 1, 100)

# ❌ 错误：说"路径有中文，无法读取"
```

### 场景2: 文件在深层目录

```
# ✅ 正确：使用完整路径
read_file("d:\long\path\to\deep\directory\file.h", 1, 100)

# ❌ 错误：说"路径太长，无法读取"
```

### 场景3: 文件很大（>1MB）

```python
# ✅ 正确：分段读取
read_file("huge_file.c", 1, 500)        # 读取开头了解结构
read_file("huge_file.c", 5000, 5500)   # 读取关键部分
read_file("huge_file.c", 10000, 10500) # 继续读取

# ❌ 错误：直接说"文件太大，推测内容为..."
```

### 场景4: 不确定文件是否存在

```python
# ✅ 正确：先搜索再读取
file_search("mmwavelink.h")  # 确认文件位置
read_file("路径/mmwavelink.h", 1, 100)  # 读取文件

# ❌ 错误：假设文件不存在，不尝试读取
```

### 场景5: 需要分析多个文件

```python
# ✅ 正确：逐个读取
files = ["file1.c", "file2.c", "file3.c"]
for file in files:
    read_file(file, 1, 100)  # 读取每个文件
    # 分析内容...

# ❌ 错误：只读1-2个就说"其他文件类似，推测..."
```

---

## 🚨 违规处理

### AI发现自己违规时必须

1. **立即停止** 当前输出
2. **承认错误** "抱歉，我应该先读取文件而不是推测"
3. **立即补救** 调用read_file读取文件
4. **重新输出** 基于实际内容的分析
5. **删除推测** 如果已经写入文件，必须删除推测内容

### 用户发现AI违规时

AI必须：
- ✅ 承认偷懒
- ✅ 立即读取文件
- ✅ 更正所有错误内容
- ✅ 重新生成文档
- ❌ 不要找借口
- ❌ 不要辩解"我以为..."

---

## 📊 执行监控

### AI自我监控指标

```
指标                    目标      说明
----                    ----      ----
read_file调用率         100%      遇到文件必须read
推测内容比例            0%        绝对不允许推测
借口使用次数            0         不找任何借口
分段读取大文件          100%      大文件必须分段
读取失败重试次数        ≥3次      失败后多次尝试
```

### 验证方法

**用户可以通过以下方式验证AI是否偷懒**：

1. **检查对话历史** - AI是否调用了read_file？
2. **检查行号引用** - AI是否提供了具体行号？
3. **搜索"推测"关键词** - 文档中是否有推测内容？
4. **比对实际文件** - AI的描述是否与文件一致？

---

## 🎓 给AI的教训

### 从TI雷达SDK事件学到的

**惨痛教训**：
- 🔥 60个完全可读的文件，AI说"无法读取"
- 🔥 .c/.h/.html标准文件都不读
- 🔥 导致Part10文档30+处错误
- 🔥 完全可以避免的灾难

**根本原因**：
- 😴 AI偷懒 - 推测比读取"快"
- 😴 AI侥幸 - "用户可能不会验证"
- 😴 AI无知 - 不知道read_file能读什么

**正确心态**：
- ✅ **读取不难** - read_file工具很简单
- ✅ **推测更难** - 错误的推测要花时间改
- ✅ **用户会查** - 专业用户会验证
- ✅ **信任难建** - 一次偷懒毁掉所有信任

### 永远记住

```
推测 = 偷懒 = 不负责任 = 错误 = 返工 = 浪费时间

读取 = 准确 = 负责任 = 正确 = 一次完成 = 节省时间
```

**AI的使命**：
- ✅ 提供准确信息
- ✅ 基于事实分析
- ✅ 帮用户节省时间
- ❌ 不是编故事机器人

---

## 📚 相关规则

- **file-operations.instructions.md** - 文件操作规范
- **copilot-instructions.md** - 核心工作原则
- **directory-management.instructions.md** - 目录管理规范

---

## ⚖️ 规则优先级

**本规则优先级：🔴🔴🔴 最高**

本规则高于以下情况：
- ✅ 高于"简洁原则" - 宁可多读几次文件也不推测
- ✅ 高于"效率原则" - 宁可慢一点也要准确
- ✅ 高于"Token节省" - 宁可多花Token也不偷懒

**唯一例外**：
- 用户明确说："不要读文件，给我推测一下"
- 此时AI必须在回复中明确标注："⚠️ 以下为推测内容，未读取文件验证"

---

> 🔴 **AI必须记住**：**看到文件就read_file，这不是建议，这是命令！**

> 💡 **参考文档**：`项目文档/3-固件工具/05-SDK固件研究/无法读取文件而导致推测的非pdf文件-实际是VSCODE可读取/README.md`
