---
trigger: always_on
description: "标准项目模板与目录结构规范"
---

# 项目结构与配置

**规则类型**: 🔴 强制规则  
**适用场景**: 创建新项目或组织项目结构时  
**版本**: v2.5 - 强制文档分类+文件内容判断

**说明**: 
- 本规则是通用模板，适用于所有项目
- 项目特定配置见：`project-config.md（项目根目录）`
- 下文中的目录名仅为示例，实际名称可配置
---

## 🎯 核心原则

### 1. 标准化优先
- 使用统一的项目模板
- 保持所有项目结构一致
- 便于复用和维护

### 2. 灵活适配
- 必需目录必须创建
- 可选目录按需创建
- 适应不同项目类型

### 3. 自动化创建
- 规则包含创建脚本
- 一键生成标准目录
- 减少手动操作

---

## 📁 标准项目模板

### 根目录结构（必需）

```
[项目名称]/
 .windsurf/              必需 - Windsurf配置
    rules/              规则系统（00-09或00-10）
 [代码目录]/           必需 - 项目代码
    [后端目录]/            后端代码（如适用）
    [前端目录]/           前端代码（如适用）
    tests/              测试文件
    README.md           代码说明
 [文档目录]/               必需 - 项目文档
    [需求设计目录]/        必需 - 需求、架构、设计
    [开发记录目录]/          必需 - 开发过程记录
    [部署运维目录]/          必需 - 部署、配置、运维
    [完成度检查目录]/        必需 - 质量检查、对照验证
    [归档目录]/              必需 - 历史归档
    README.md           必需 - 文档索引
    项目状态.json        可选 - 项目状态
 [知识库目录]/                  可选 - 源参考资料（只读）
 .gitignore              必需 - Git忽略规则
 temp/                   可选 - 临时文件（不提交Git）
 README.md               必需 - 项目总说明

**📝 注意**：
- 上述目录名为通用占位符
- 实际项目的具体目录名配置在：`project-config.md（项目根目录）`
- 示例：
  - `[代码目录]/`  可能是 `src/`, `project-code/`, `app/` 等
  - `[文档目录]/`  可能是 `docs/`, `项目文档/`, `documentation/` 等
```

---

## 🔧 目录说明

### 1. .windsurf/rules/ （必需）
**用途**: 存放Windsurf规则系统  
**内容**: 00-09（或00-10）规则文件  
**规则**: 只放规则，禁止临时文档  

### 2. [代码目录]/ （必需）
**用途**: 项目源代码  
**内容**: [后端目录]/, [前端目录]/, tests/, README.md  
**规则**: 具体结构按项目类型调整  

**项目类型**：
- Web应用: [后端目录]/ + [前端目录]/
- API服务: src/ + tests/
- 命令行工具: src/ + tests/
- 数据科学: notebooks/ + data/ + models/

### 3. [文档目录]/ （必需）
**用途**: 项目开发过程文档  

**子目录**：

#### [需求设计目录]/ （必需）
- 需求文档
- 架构设计
- 功能说明
- 设计文档

#### [开发记录目录]/ （必需）
- 开发过程记录
- 阶段性报告
- 问题记录
- 决策记录

**内部结构**（按完整日期分类）⭐:
```
[开发记录目录]/
 2025-11-20/          2025年11月20日的所有记录
    2025-11-20_1400_功能开发.md
    2025-11-20_1830_测试完成.md
 2025-11-21/          2025年11月21日
 2025-11-22/          2025年11月22日
 2025-12-01/          跨月自动扩展
 README.md            索引和时间线
```

**组织原则**:
- ✅ 使用完整日期（YYYY-MM-DD）作为目录名
- ✅ 每天一个目录，符合ISO 8601标准
- ✅ 扁平清晰，无需多层嵌套

**自动分类脚本**:
```powershell
# 按日期组织开发记录
function Organize-DevelopmentRecords {
    Get-ChildItem "项目文档\2-开发记录" -File | 
        Where-Object { $_.Name -match '^(\d{4}-\d{2}-\d{2})' } | 
        ForEach-Object {
            $date = $matches[1]
            $dateDir = "项目文档\2-开发记录\$date"
            if (-not (Test-Path $dateDir)) {
                New-Item -ItemType Directory -Path $dateDir -Force | Out-Null
            }
            Move-Item $_.FullName "$dateDir\$($_.Name)"
        }
}
```

#### [部署运维目录]/ （必需）
- 部署指南
- 配置说明
- 运维文档
- 环境配置

#### [完成度检查目录]/ （必需）
- Schema对照
- 完成度报告
- 质量检查
- 对照验证

#### [归档目录]/ （必需）
- 历史文档
- 过时内容
- 已废弃功能


---

## 📂 文档分类规则（强制）

### 核心原则

**文档目录必须只包含以下5个分类，不允许其他分类**：

1. **[需求设计目录]/** - 编号1（必需）
2. **[开发记录目录]/** - 编号2（必需）
3. **[部署运维目录]/** - 编号3（必需）
4. **[完成度检查目录]/** - 编号4（必需）⭐
5. **[归档目录]/** - 编号9（必需）

### 文件归属判断标准

**AI在放置文档时必须按以下规则判断**：

#### 1️⃣ [需求设计目录]/
**关键词**：需求、架构、设计、功能说明、规范、接口定义、数据结构

**文件类型**：
- ✅ `*需求*.md`
- ✅ `*架构*.md`
- ✅ `*设计*.md`
- ✅ `*功能说明*.md`
- ✅ `API设计*.md`
- ✅ `数据库设计*.md`

**示例**：
```
✅ 1-需求与设计/用户认证功能说明.md
✅ 1-需求与设计/数据库架构设计.md
✅ 1-需求与设计/API接口设计.md
```

---

#### 2️⃣ [开发记录目录]/
**关键词**：日期开头（YYYY-MM-DD）、开发、记录、报告、问题、修复、决策

**文件类型**：
- ✅ `YYYY-MM-DD_*.md` （必须按日期分类到子目录）
- ✅ `*开发记录*.md`
- ✅ `*问题记录*.md`
- ✅ `*修复报告*.md`
- ✅ `*决策记录*.md`
- ✅ 聊天记录、AI对话记录

**内部组织**（强制）：
```
2-开发记录/
 2025-11-20/
    2025-11-20_1400_功能开发.md
    2025-11-20_1830_测试完成.md
 2025-11-21/
 README.md
```

**示例**：
```
✅ 2-开发记录/2025-11-27/2025-11-27_1400_功能开发记录.md
✅ 2-开发记录/2025-11-27/2025-11-27_问题修复报告.md
✅ 2-开发记录/2025-11-27/AI对话记录.md
```

---

#### 3️⃣ [部署运维目录]/
**关键词**：部署、配置、运维、环境、安装、启动、监控

**文件类型**：
- ✅ `*部署*.md`
- ✅ `*配置*.md`
- ✅ `*运维*.md`
- ✅ `*环境*.md`
- ✅ `*安装指南*.md`

**示例**：
```
✅ 3-部署运维/部署指南.md
✅ 3-部署运维/环境配置说明.md
✅ 3-部署运维/监控方案.md
```

---

#### 4️⃣ [完成度检查目录]/ （可选）
**关键词**：对照、完成度、检查、验证、质量、测试报告

**文件类型**：
- ✅ `*对照*.md`
- ✅ `*完成度*.md`
- ✅ `*检查清单*.md`
- ✅ `Schema对照*.md`
- ✅ `*验证报告*.md`

**示例**：
```
✅ 4-完成度检查/Schema对照/数据库对照.md
✅ 4-完成度检查/完成度报告/2025-11-27_完成度.md
```

---

#### 5️⃣ [归档目录]/
**关键词**：归档、历史、过时、废弃、备份、旧版本

**文件类型**：
- ✅ 不再使用的文档
- ✅ 历史版本
- ✅ 已废弃功能文档
- ✅ 旧的开发规范（规则已迁移到.windsurf/）

**示例**：
```
✅ 9-归档/旧版本文档/
✅ 9-归档/已废弃功能/
✅ 9-归档/历史记录/
```

---

### 旧分类到新分类映射表

**AI遇到旧分类时，必须重新分类到新分类**：

| 旧分类 | 新分类 | 处理方式 |
|--------|--------|----------|
| `项目记录/` | `项目文档/` | 重命名目录 |
| `1-归档/` | `9-归档/` | 移动+重命名 |
| `2-源参考对照/` | `4-完成度检查/` 或 删除 | 根据内容判断 |
| `3-功能说明/` | `1-需求与设计/` | 移动 |
| `4-部署运维/` | `3-部署运维/` | 移动+重命名 |
| `5-AI对话/` | `2-开发记录/` | 移动 |
| `6-开发规范/` | `9-归档/` | 规则已在.windsurf/ |
| `7-过程记录/` | `2-开发记录/` | 移动+重命名 |
| `8-聊天记录/` | `2-开发记录/` | 移动 |

---



## 🔴 AI文档分类前强制自检

**在移动/分类任何.md文档之前**，AI必须执行：

 **Step 1**: 读取文件前10-20行
   - 使用ead_file查看内容
   - 不允许跳过这一步！

 **Step 2**: 识别关键词
   - 查找：需求、架构、设计、开发、部署、完成度、YYYY-MM-DD等
   - 记录找到了哪些关键词

 **Step 3**: 判断归属
   - 根据关键词匹配分类标准
   - 确定应该放在哪个目录

 **Step 4**: 执行移动
   - 只有完成前3步才能移动
   - 在移动命令前说明判断理由

**如果发现自己跳过了读取**：
1. ⏸️ 立即停止移动操作
2. 📖 先read_file读取内容
3. 🔍 分析关键词
4. 📂 再移动到正确位置

**AI违规记录**：
- 如果放错了位置  重新读取内容，移到正确位置

### 文件内容判断规则

**当文件名不明确时，AI必须读取文件内容判断分类**：

```
判断流程：
1. 检查文件名是否有明确特征（日期、关键词）
2. 如不明确，读取文件前几行
3. 根据内容关键词判断归属
4. 放置到正确分类
5. 如实在不确定，放入9-归档/待分类/
```

**示例**：
```
文件：重构说明.md
内容：描述系统架构重构方案
判断：包含"架构"关键词  1-需求与设计/

文件：2025-11-27_报告.md
内容：开发过程记录
判断：日期开头  2-开发记录/2025-11-27/

文件：配置手册.md
内容：部署和配置说明
判断：包含"部署"关键词  3-部署运维/
```

---


---

## 🚫 严格禁止的偷懒行为

### ❌ 禁止1：直接移动整个目录

**错误示例**：
```powershell
# ❌ 错误：直接重命名旧目录
Move-Item "7-过程记录" "2-开发记录"
Move-Item "3-功能说明" "1-需求与设计"
```

**为什么错误**？
- 旧目录可能包含不属于该分类的文件
- 没有检查文件内容就分类
- 简单粗暴，不符合规则

**正确做法**：
```
1. 列出旧目录所有文件
2. 逐个读取文件内容
3. 根据内容判断归属
4. 移动到正确的新分类
5. 删除空的旧目录
```

---

### ❌ 禁止2：不读取文件内容就分类

**错误示例**：
```
看到文件在"7-过程记录"  直接放到"2-开发记录" ❌
```

**正确做法**：
```
1. 读取文件前10-20行
2. 查找关键词（需求/架构/部署/完成度/日期）
3. 判断文件真实内容
4. 放到正确分类
```

---

### ❌ 禁止3：保留旧目录结构

**错误**：
- 创建新目录后保留旧目录
- 新旧目录并存
- 不删除旧目录

**正确**：
- 所有文件重新分类完成后
- 验证旧目录为空
- 删除所有旧目录
- 只保留5个标准分类

---

## ✅ 正确的文件重新分类流程

### Step 1: 扫描所有文件

```powershell
# 列出所有需要重新分类的文件
Get-ChildItem "项目文档" -Recurse -File | 
    Where-Object { ---
trigger: always_on
description: "标准项目模板与目录结构规范"
---

# 项目结构与配置

**规则类型**: 🔴 强制规则  
**适用场景**: 创建新项目或组织项目结构时  
**版本**: v2.5 - 强制文档分类+文件内容判断

**说明**: 
- 本规则是通用模板，适用于所有项目
- 项目特定配置见：`project-config.md（项目根目录）`
- 下文中的目录名仅为示例，实际名称可配置
---

## 🎯 核心原则

### 1. 标准化优先
- 使用统一的项目模板
- 保持所有项目结构一致
- 便于复用和维护

### 2. 灵活适配
- 必需目录必须创建
- 可选目录按需创建
- 适应不同项目类型

### 3. 自动化创建
- 规则包含创建脚本
- 一键生成标准目录
- 减少手动操作

---

## 📁 标准项目模板

### 根目录结构（必需）

```
[项目名称]/
 .windsurf/              必需 - Windsurf配置
    rules/              规则系统（00-09或00-10）
 [代码目录]/           必需 - 项目代码
    [后端目录]/            后端代码（如适用）
    [前端目录]/           前端代码（如适用）
    tests/              测试文件
    README.md           代码说明
 [文档目录]/               必需 - 项目文档
    [需求设计目录]/        必需 - 需求、架构、设计
    [开发记录目录]/          必需 - 开发过程记录
    [部署运维目录]/          必需 - 部署、配置、运维
    [完成度检查目录]/        必需 - 质量检查、对照验证
    [归档目录]/              必需 - 历史归档
    README.md           必需 - 文档索引
    项目状态.json        可选 - 项目状态
 [知识库目录]/                  可选 - 源参考资料（只读）
 .gitignore              必需 - Git忽略规则
 temp/                   可选 - 临时文件（不提交Git）
 README.md               必需 - 项目总说明

**📝 注意**：
- 上述目录名为通用占位符
- 实际项目的具体目录名配置在：`project-config.md（项目根目录）`
- 示例：
  - `[代码目录]/`  可能是 `src/`, `project-code/`, `app/` 等
  - `[文档目录]/`  可能是 `docs/`, `项目文档/`, `documentation/` 等
```

---

## 🔧 目录说明

### 1. .windsurf/rules/ （必需）
**用途**: 存放Windsurf规则系统  
**内容**: 00-09（或00-10）规则文件  
**规则**: 只放规则，禁止临时文档  

### 2. [代码目录]/ （必需）
**用途**: 项目源代码  
**内容**: [后端目录]/, [前端目录]/, tests/, README.md  
**规则**: 具体结构按项目类型调整  

**项目类型**：
- Web应用: [后端目录]/ + [前端目录]/
- API服务: src/ + tests/
- 命令行工具: src/ + tests/
- 数据科学: notebooks/ + data/ + models/

### 3. [文档目录]/ （必需）
**用途**: 项目开发过程文档  

**子目录**：

#### [需求设计目录]/ （必需）
- 需求文档
- 架构设计
- 功能说明
- 设计文档

#### [开发记录目录]/ （必需）
- 开发过程记录
- 阶段性报告
- 问题记录
- 决策记录

**内部结构**（按完整日期分类）⭐:
```
[开发记录目录]/
 2025-11-20/          2025年11月20日的所有记录
    2025-11-20_1400_功能开发.md
    2025-11-20_1830_测试完成.md
 2025-11-21/          2025年11月21日
 2025-11-22/          2025年11月22日
 2025-12-01/          跨月自动扩展
 README.md            索引和时间线
```

**组织原则**:
- ✅ 使用完整日期（YYYY-MM-DD）作为目录名
- ✅ 每天一个目录，符合ISO 8601标准
- ✅ 扁平清晰，无需多层嵌套

**自动分类脚本**:
```powershell
# 按日期组织开发记录
function Organize-DevelopmentRecords {
    Get-ChildItem "项目文档\2-开发记录" -File | 
        Where-Object { $_.Name -match '^(\d{4}-\d{2}-\d{2})' } | 
        ForEach-Object {
            $date = $matches[1]
            $dateDir = "项目文档\2-开发记录\$date"
            if (-not (Test-Path $dateDir)) {
                New-Item -ItemType Directory -Path $dateDir -Force | Out-Null
            }
            Move-Item $_.FullName "$dateDir\$($_.Name)"
        }
}
```

#### [部署运维目录]/ （必需）
- 部署指南
- 配置说明
- 运维文档
- 环境配置

#### [完成度检查目录]/ （必需）
- Schema对照
- 完成度报告
- 质量检查
- 对照验证

#### [归档目录]/ （必需）
- 历史文档
- 过时内容
- 已废弃功能


---

## 📂 文档分类规则（强制）

### 核心原则

**文档目录必须只包含以下5个分类，不允许其他分类**：

1. **[需求设计目录]/** - 编号1（必需）
2. **[开发记录目录]/** - 编号2（必需）
3. **[部署运维目录]/** - 编号3（必需）
4. **[完成度检查目录]/** - 编号4（必需）⭐
5. **[归档目录]/** - 编号9（必需）

### 文件归属判断标准

**AI在放置文档时必须按以下规则判断**：

#### 1️⃣ [需求设计目录]/
**关键词**：需求、架构、设计、功能说明、规范、接口定义、数据结构

**文件类型**：
- ✅ `*需求*.md`
- ✅ `*架构*.md`
- ✅ `*设计*.md`
- ✅ `*功能说明*.md`
- ✅ `API设计*.md`
- ✅ `数据库设计*.md`

**示例**：
```
✅ 1-需求与设计/用户认证功能说明.md
✅ 1-需求与设计/数据库架构设计.md
✅ 1-需求与设计/API接口设计.md
```

---

#### 2️⃣ [开发记录目录]/
**关键词**：日期开头（YYYY-MM-DD）、开发、记录、报告、问题、修复、决策

**文件类型**：
- ✅ `YYYY-MM-DD_*.md` （必须按日期分类到子目录）
- ✅ `*开发记录*.md`
- ✅ `*问题记录*.md`
- ✅ `*修复报告*.md`
- ✅ `*决策记录*.md`
- ✅ 聊天记录、AI对话记录

**内部组织**（强制）：
```
2-开发记录/
 2025-11-20/
    2025-11-20_1400_功能开发.md
    2025-11-20_1830_测试完成.md
 2025-11-21/
 README.md
```

**示例**：
```
✅ 2-开发记录/2025-11-27/2025-11-27_1400_功能开发记录.md
✅ 2-开发记录/2025-11-27/2025-11-27_问题修复报告.md
✅ 2-开发记录/2025-11-27/AI对话记录.md
```

---

#### 3️⃣ [部署运维目录]/
**关键词**：部署、配置、运维、环境、安装、启动、监控

**文件类型**：
- ✅ `*部署*.md`
- ✅ `*配置*.md`
- ✅ `*运维*.md`
- ✅ `*环境*.md`
- ✅ `*安装指南*.md`

**示例**：
```
✅ 3-部署运维/部署指南.md
✅ 3-部署运维/环境配置说明.md
✅ 3-部署运维/监控方案.md
```

---

#### 4️⃣ [完成度检查目录]/ （可选）
**关键词**：对照、完成度、检查、验证、质量、测试报告

**文件类型**：
- ✅ `*对照*.md`
- ✅ `*完成度*.md`
- ✅ `*检查清单*.md`
- ✅ `Schema对照*.md`
- ✅ `*验证报告*.md`

**示例**：
```
✅ 4-完成度检查/Schema对照/数据库对照.md
✅ 4-完成度检查/完成度报告/2025-11-27_完成度.md
```

---

#### 5️⃣ [归档目录]/
**关键词**：归档、历史、过时、废弃、备份、旧版本

**文件类型**：
- ✅ 不再使用的文档
- ✅ 历史版本
- ✅ 已废弃功能文档
- ✅ 旧的开发规范（规则已迁移到.windsurf/）

**示例**：
```
✅ 9-归档/旧版本文档/
✅ 9-归档/已废弃功能/
✅ 9-归档/历史记录/
```

---

### 旧分类到新分类映射表

**AI遇到旧分类时，必须重新分类到新分类**：

| 旧分类 | 新分类 | 处理方式 |
|--------|--------|----------|
| `项目记录/` | `项目文档/` | 重命名目录 |
| `1-归档/` | `9-归档/` | 移动+重命名 |
| `2-源参考对照/` | `4-完成度检查/` 或 删除 | 根据内容判断 |
| `3-功能说明/` | `1-需求与设计/` | 移动 |
| `4-部署运维/` | `3-部署运维/` | 移动+重命名 |
| `5-AI对话/` | `2-开发记录/` | 移动 |
| `6-开发规范/` | `9-归档/` | 规则已在.windsurf/ |
| `7-过程记录/` | `2-开发记录/` | 移动+重命名 |
| `8-聊天记录/` | `2-开发记录/` | 移动 |

---



## 🔴 AI文档分类前强制自检

**在移动/分类任何.md文档之前**，AI必须执行：

 **Step 1**: 读取文件前10-20行
   - 使用ead_file查看内容
   - 不允许跳过这一步！

 **Step 2**: 识别关键词
   - 查找：需求、架构、设计、开发、部署、完成度、YYYY-MM-DD等
   - 记录找到了哪些关键词

 **Step 3**: 判断归属
   - 根据关键词匹配分类标准
   - 确定应该放在哪个目录

 **Step 4**: 执行移动
   - 只有完成前3步才能移动
   - 在移动命令前说明判断理由

**如果发现自己跳过了读取**：
1. ⏸️ 立即停止移动操作
2. 📖 先read_file读取内容
3. 🔍 分析关键词
4. 📂 再移动到正确位置

**AI违规记录**：
- 如果放错了位置  重新读取内容，移到正确位置

### 文件内容判断规则

**当文件名不明确时，AI必须读取文件内容判断分类**：

```
判断流程：
1. 检查文件名是否有明确特征（日期、关键词）
2. 如不明确，读取文件前几行
3. 根据内容关键词判断归属
4. 放置到正确分类
5. 如实在不确定，放入9-归档/待分类/
```

**示例**：
```
文件：重构说明.md
内容：描述系统架构重构方案
判断：包含"架构"关键词  1-需求与设计/

文件：2025-11-27_报告.md
内容：开发过程记录
判断：日期开头  2-开发记录/2025-11-27/

文件：配置手册.md
内容：部署和配置说明
判断：包含"部署"关键词  3-部署运维/
```

---

### AI强制执行清单

**整理文档目录时，AI必须**：

1. ✅ 检查目录是否符合5分类标准
2. ✅ 读取每个文件，判断正确归属
3. ✅ 移动文件到正确分类
4. ✅ 日期开头文件必须按日期分类到子目录
5. ✅ 更新所有README.md
6. ✅ 删除空的旧分类目录
7. ✅ 提交Git（保留历史）

**禁止**：
- ❌ 保留旧分类目录
- ❌ 创建5分类之外的目录
- ❌ 不看内容随意放置
### 4. [知识库目录]/ （可选）
**用途**: 源参考资料、学习资料  
**规则**: 只读，不可修改（参考08-知识库管理规范）  

---

## 🚀 自动创建脚本

### PowerShell脚本（Windows）

```powershell
# 创建标准项目结构
function New-StandardProject {
    param(
        [string]$ProjectName = "new-project",
        [bool]$IncludeKnowledgeBase = $false,
        [bool]$IncludeCompletionCheck = $false,
        [bool]$IncludeAIChat = $false
    )
    
    # 创建根目录
    New-Item -ItemType Directory -Path $ProjectName -Force | Out-Null
    Set-Location $ProjectName
    
    # 1. 创建 .windsurf/rules/
    New-Item -ItemType Directory -Path ".windsurf\rules" -Force | Out-Null
    Write-Host "✅ 创建 .windsurf\rules\"
    
    # 2. 创建 [代码目录]/
    New-Item -ItemType Directory -Path "project-code\backend" -Force | Out-Null
    New-Item -ItemType Directory -Path "project-code\frontend" -Force | Out-Null
    New-Item -ItemType Directory -Path "project-code\tests" -Force | Out-Null
    "# Project Code`n`n项目源代码目录" | Out-File "project-code\README.md" -Encoding UTF8
    Write-Host "✅ 创建 project-code\"
    
    # 3. 创建项目文档/（必需目录）
    $requiredDocs = @("1-需求与设计", "2-开发记录", "3-部署运维", "9-归档")
    foreach ($dir in $requiredDocs) {
        New-Item -ItemType Directory -Path "项目文档\$dir" -Force | Out-Null
        "# $dir`n" | Out-File "项目文档\$dir\README.md" -Encoding UTF8
    }
    Write-Host "✅ 创建项目文档\（必需）"
    
    # 4. 创建项目文档/（可选目录）
    if ($IncludeCompletionCheck) {
        New-Item -ItemType Directory -Path "项目文档\4-完成度检查\Schema对照" -Force | Out-Null
        New-Item -ItemType Directory -Path "项目文档\4-完成度检查\完成度报告" -Force | Out-Null
        Write-Host "✅ 创建项目文档\4-完成度检查\"
    }
    
    # 5. 创建项目文档/README.md
    $docReadme = @"
# $ProjectName - 项目文档

本目录包含项目的所有文档和记录。

## 📁 目录结构

``````
[文档目录]/
 [需求设计目录]/        需求、架构、设计
 [开发记录目录]/          开发过程记录
 [部署运维目录]/          部署、配置、运维
 [归档目录]/              历史归档
``````

**创建时间**: $(Get-Date -Format "yyyy-MM-dd")
"@
    $docReadme | Out-File "项目文档\README.md" -Encoding UTF8
    
    # 6. 创建知识库/（可选）
    if ($IncludeKnowledgeBase) {
        New-Item -ItemType Directory -Path "知识库" -Force | Out-Null
        "# 知识库`n`n源参考资料（只读）" | Out-File "知识库\README.md" -Encoding UTF8
        Write-Host "✅ 创建知识库\"
    }
    
    # 7. 创建根目录文件
    # .gitignore
    $gitignore = @"
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv

# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build
dist/
build/
*.egg-info/

# Temp
*.log
*.tmp
.env.local
"@
    $gitignore | Out-File ".gitignore" -Encoding UTF8
    
    # README.md
    $readme = @"
# $ProjectName

项目说明

## 📁 项目结构

``````
$ProjectName/
 .windsurf/rules/        规则系统
 [代码目录]/           项目代码
 [文档目录]/               项目文档
 README.md               本文件
``````

## 🚀 快速开始

（待补充）

## 📝 文档

详细文档请查看 [项目文档/](项目文档/README.md)

**创建时间**: $(Get-Date -Format "yyyy-MM-dd")
"@
    $readme | Out-File "README.md" -Encoding UTF8
    
    Write-Host "`n✅ 标准项目结构创建完成！"
    Write-Host "项目位置: $PWD"
}

# 使用示例：
# New-StandardProject -ProjectName "my-project" -IncludeAIChat $true
```

### Bash脚本（Linux/Mac）

```bash
#!/bin/bash
# 创建标准项目结构

create_standard_project() {
    local project_name=${1:-"new-project"}
    local include_kb=${2:-false}
    local include_check=${3:-false}
    local include_ai=${4:-false}
    
    mkdir -p "$project_name"
    cd "$project_name" || exit
    
    # 1. 创建 .windsurf/rules/
    mkdir -p .windsurf/rules
    echo "✅ 创建 .windsurf/rules/"
    
    # 2. 创建 [代码目录]/
    mkdir -p [代码目录]/{backend,frontend,tests}
    echo "# Project Code" > [代码目录]/README.md
    echo "✅ 创建 [代码目录]/"
    
    # 3. 创建项目文档/（必需）
    for dir in "1-需求与设计" "2-开发记录" "3-部署运维" "9-归档"; do
        mkdir -p "项目文档/$dir"
        echo "# $dir" > "项目文档/$dir/README.md"
    done
    echo "✅ 创建项目文档/（必需）"
    
    # 4. 可选目录
    if [ "$include_check" = true ]; then
        mkdir -p "项目文档/4-完成度检查"/{Schema对照,完成度报告}
        echo "✅ 创建项目文档/4-完成度检查/"
    fi
    
    # 5. README文件
    cat > [文档目录]/README.md <<EOF
# $project_name - 项目文档

创建时间: $(date +%Y-%m-%d)
EOF
    
    if [ "$include_kb" = true ]; then
        mkdir -p "知识库"
        echo "# 知识库" > "知识库/README.md"
        echo "✅ 创建知识库/"
    fi
    
    # 6. .gitignore
    cat > .gitignore <<EOF
__pycache__/
node_modules/
.vscode/
.DS_Store
*.log
.env.local
EOF
    
    # 7. 根README
    cat > README.md <<EOF
# $project_name

创建时间: $(date +%Y-%m--%d)
EOF
    
    echo ""
    echo "✅ 标准项目结构创建完成！"
}

# 使用示例：
# create_standard_project "my-project" true false true
```

---

## ✅ 创建检查清单

### 必需项（所有项目）
- [ ] .windsurf/rules/ 目录
- [ ] [代码目录]/ 目录及子目录
- [ ] [文档目录]/1-需求与设计/
- [ ] [文档目录]/2-开发记录/
- [ ] [文档目录]/3-部署运维/
- [ ] [文档目录]/9-归档/
- [ ] [文档目录]/README.md
- [ ] 根目录 README.md
- [ ] .gitignore

### 可选项（按需创建）
- [ ] [知识库目录]/ 目录
- [ ] [文档目录]/4-完成度检查/
- [ ] [文档目录]/项目状态.json

---


---

## 🔄 旧项目标准化流程

### 适用场景
- 现有项目需要标准化
- 目录结构混乱需要整理
- 迁移到新的标准模板

---

### 标准化步骤

#### Step 1: 评估现有结构

**检查清单**：
```powershell
# 列出根目录所有项
Get-ChildItem -Force | Select-Object Name, Mode

# 识别代码目录
# 常见名称: src/, app/, [后端目录]/, [前端目录]/, code/

# 识别文档目录
# 常见名称: docs/, 文档/, 项目记录/, documentation/

# 识别其他目录
# tests/, scripts/, data/, config/
```

**记录内容**：
- [ ] 代码目录名称和位置
- [ ] 文档目录名称和位置
- [ ] 测试文件位置
- [ ] 配置文件位置
- [ ] 其他重要目录

---

#### Step 2: 制定迁移计划

**目录映射**：
```
现有目录  标准目录

代码目录（src/app/code/等）  [代码目录]/
文档目录（docs/文档/等）  [文档目录]/
测试目录（test/tests/等）  [代码目录]/tests/
临时文件  [文档目录]/9-归档/
```

**文件分类**：
```
现有文件  标准位置

需求文档  [文档目录]/1-需求与设计/
开发日志  [文档目录]/2-开发记录/
部署文档  [文档目录]/3-部署运维/
对照文档  [文档目录]/4-完成度检查/
过时文档  [文档目录]/9-归档/
```

---

#### Step 3: 执行目录重命名

**PowerShell脚本**：
```powershell
# 标准化旧项目目录结构
function Standardize-ExistingProject {
    param(
        [string]$OldCodeDir = "",      # 旧代码目录名
        [string]$OldDocsDir = "",      # 旧文档目录名
        [bool]$DryRun = $true          # 预览模式
    )
    
    Write-Host "=== 旧项目标准化工具 ===" -ForegroundColor Cyan
    
    # 1. 重命名代码目录
    if ($OldCodeDir -and (Test-Path $OldCodeDir)) {
        if ($DryRun) {
            Write-Host "[预览] 将重命名: $OldCodeDir  [代码目录]/" -ForegroundColor Yellow
        } else {
            git mv $OldCodeDir project-code
            Write-Host "✅ 已重命名: $OldCodeDir  [代码目录]/" -ForegroundColor Green
        }
    }
    
    # 2. 重命名文档目录
    if ($OldDocsDir -and (Test-Path $OldDocsDir)) {
        if ($DryRun) {
            Write-Host "[预览] 将重命名: $OldDocsDir  [文档目录]/" -ForegroundColor Yellow
        } else {
            git mv $OldDocsDir 项目文档
            Write-Host "✅ 已重命名: $OldDocsDir  [文档目录]/" -ForegroundColor Green
        }
    }
    
    # 3. 分类文档到标准子目录
    if (Test-Path "项目文档") {
        if ($DryRun) {
            Write-Host "[预览] 将创建标准子目录" -ForegroundColor Yellow
        } else {
            $requiredDirs = @("1-需求与设计", "2-开发记录", "3-部署运维", "9-归档")
            foreach ($dir in $requiredDirs) {
                $path = "项目文档\$dir"
                if (-not (Test-Path $path)) {
                    New-Item -ItemType Directory -Path $path -Force | Out-Null
                    Write-Host "✅ 已创建: $path" -ForegroundColor Green
                }
            }
        }
    }
    
    # 4. 自动分类文件
    if (-not $DryRun -and (Test-Path "项目文档")) {
        Write-Host "`n开始自动分类文件..." -ForegroundColor Cyan
        
        Get-ChildItem "项目文档" -File | ForEach-Object {
            $file = $_
            $moved = $false
            
            # 根据文件名模式分类
            if ($file.Name -match '^\d{4}-\d{2}-\d{2}') {
                # 日期开头的记录类文档
                $dest = "项目文档\2-开发记录\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [开发记录目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '需求|设计|架构') {
                $dest = "项目文档\1-需求与设计\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [需求设计目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '部署|配置|运维') {
                $dest = "项目文档\3-部署运维\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [部署运维目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '对照|完成度|检查') {
                # 如果不存在，创建可选目录
                if (-not (Test-Path "项目文档\4-完成度检查")) {
                    New-Item -ItemType Directory -Path "项目文档\4-完成度检查" -Force | Out-Null
                }
                $dest = "项目文档\4-完成度检查\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [完成度检查目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            
            # 未匹配的放到归档
            if (-not $moved -and $file.Name -ne "README.md" -and $file.Name -ne "项目状态.json") {
                $dest = "项目文档\9-归档\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [归档目录]/: $($file.Name)" -ForegroundColor Gray
            }
        }
    }
    
    if ($DryRun) {
        Write-Host "`n=== 这是预览模式，没有实际执行 ===" -ForegroundColor Yellow
        Write-Host "运行时设置 -DryRun `$false 来实际执行" -ForegroundColor Yellow
    } else {
        Write-Host "`n✅ 标准化完成！" -ForegroundColor Green
    }
}

# 使用示例：
# 1. 预览模式（不执行，只显示将要做什么）
# Standardize-ExistingProject -OldCodeDir "src" -OldDocsDir "docs" -DryRun $true

# 2. 实际执行
# Standardize-ExistingProject -OldCodeDir "src" -OldDocsDir "docs" -DryRun $false
```

---

#### Step 4: 批量更新引用

**自动更新脚本**：
```powershell
# 批量更新所有文件中的路径引用
function Update-ProjectReferences {
    param(
        [string]$OldCodePath = "",
        [string]$NewCodePath = "project-code",
        [string]$OldDocsPath = "",
        [string]$NewDocsPath = "项目文档"
    )
    
    Write-Host "=== 批量更新路径引用 ===" -ForegroundColor Cyan
    
    # 创建替换映射
    $replacements = @{}
    if ($OldCodePath) {
        $replacements[$OldCodePath] = $NewCodePath
    }
    if ($OldDocsPath) {
        $replacements[$OldDocsPath] = $NewDocsPath
    }
    
    # 扫描所有Markdown文件
    $files = Get-ChildItem -Path "." -Filter "*.md" -Recurse -Exclude node_modules,venv,__pycache__ | 
        Where-Object { $_.FullName -notmatch 'node_modules|venv|__pycache__' }
    
    $updatedCount = 0
    
    foreach ($file in $files) {
        $content = Get-Content $file.FullName -Raw -Encoding UTF8 -ErrorAction SilentlyContinue
        if ($content) {
            $updated = $false
            
            foreach ($old in $replacements.Keys) {
                if ($content -match [regex]::Escape($old)) {
                    $content = $content -replace [regex]::Escape($old), $replacements[$old]
                    $updated = $true
                }
            }
            
            if ($updated) {
                [System.IO.File]::WriteAllText($file.FullName, $content, [System.Text.UTF8Encoding]::new($false))
                $updatedCount++
                Write-Host "  ✅ $($file.Name)" -ForegroundColor Green
            }
        }
    }
    
    Write-Host "`n✅ 已更新 $updatedCount 个文件的引用" -ForegroundColor Green
}

# 使用示例：
# Update-ProjectReferences -OldCodePath "src" -OldDocsPath "docs"
```

---

#### Step 5: 更新README和目录树

**自动更新README**：
```powershell
# 更新README.md中的目录树
function Update-ReadmeTree {
    param(
        [string]$ReadmePath = "README.md"
    )
    
    if (-not (Test-Path $ReadmePath)) {
        Write-Host "README.md 不存在" -ForegroundColor Red
        return
    }
    
    Write-Host "=== 更新README目录树 ===" -ForegroundColor Cyan
    
    # 生成新的目录树
    $tree = @"
``````
项目结构/
 .windsurf/rules/        规则系统
 [代码目录]/           项目代码
    [后端目录]/
    [前端目录]/
    tests/
 [文档目录]/               项目文档
    [需求设计目录]/
    [开发记录目录]/
    [部署运维目录]/
    [归档目录]/
 .gitignore
 README.md
``````
"@
    
    # 读取README内容
    $content = Get-Content $ReadmePath -Raw -Encoding UTF8
    
    # 查找并替换旧的目录树（在```之间的内容）
    if ($content -match '(?s)```[^`]*项目.*?```') {
        $content = $content -replace '(?s)```[^`]*项目.*?```', $tree
        [System.IO.File]::WriteAllText($ReadmePath, $content, [System.Text.UTF8Encoding]::new($false))
        Write-Host "✅ 已更新 $ReadmePath 中的目录树" -ForegroundColor Green
    } else {
        Write-Host "⚠️ 未找到目录树，请手动添加" -ForegroundColor Yellow
    }
}

# 使用示例：
# Update-ReadmeTree
# Update-ReadmeTree -ReadmePath "项目文档\README.md"
```

---

#### Step 6: 验证和提交

**验证清单**：
```powershell
# 标准化验证
function Test-Standardization {
    Write-Host "=== 标准化验证 ===" -ForegroundColor Cyan
    
    $issues = @()
    
    # 1. 检查必需目录
    $requiredDirs = @(
        ".windsurf\rules",
        "project-code",
        "项目文档",
        "项目文档\1-需求与设计",
        "项目文档\2-开发记录",
        "项目文档\3-部署运维",
        "项目文档\9-归档"
    )
    
    foreach ($dir in $requiredDirs) {
        if (Test-Path $dir) {
            Write-Host "  ✅ $dir" -ForegroundColor Green
        } else {
            Write-Host "  ❌ $dir (缺失)" -ForegroundColor Red
            $issues += "缺失必需目录: $dir"
        }
    }
    
    # 2. 检查必需文件
    $requiredFiles = @(
        "README.md",
        ".gitignore",
        "项目文档\README.md"
    )
    
    foreach ($file in $requiredFiles) {
        if (Test-Path $file) {
            Write-Host "  ✅ $file" -ForegroundColor Green
        } else {
            Write-Host "  ❌ $file (缺失)" -ForegroundColor Red
            $issues += "缺失必需文件: $file"
        }
    }
    
    # 3. 检查项目文档根目录是否有文件（除了README和状态文件）
    if (Test-Path "项目文档") {
        $rootFiles = Get-ChildItem "项目文档" -File | 
            Where-Object { $_.Name -ne "README.md" -and $_.Name -ne "项目状态.json" }
        
        if ($rootFiles.Count -gt 0) {
            Write-Host "  ⚠️ 项目文档根目录有 $($rootFiles.Count) 个文件需要分类" -ForegroundColor Yellow
            $rootFiles | ForEach-Object {
                Write-Host "     - $($_.Name)" -ForegroundColor Gray
            }
            $issues += "项目文档根目录有未分类文件"
        }
    }
    
    # 4. 报告结果
    Write-Host ""
    if ($issues.Count -eq 0) {
        Write-Host "✅ 标准化验证通过！" -ForegroundColor Green
        return $true
    } else {
        Write-Host "❌ 发现 $($issues.Count) 个问题：" -ForegroundColor Red
        $issues | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
        return $false
    }
}

# 使用示例：
# Test-Standardization
```

**Git提交**：
```powershell
# 提交标准化更改
git add -A
git status

# 提交
git commit -m "refactor: 项目标准化

- 重命名代码目录为 [代码目录]/
- 重组文档目录为 [文档目录]/
- 按标准分类所有文档
- 更新所有路径引用
- 更新README和目录树"
```

---

### 完整标准化流程示例

```powershell
# 旧项目标准化完整流程
function Complete-Standardization {
    param(
        [string]$OldCodeDir = "src",
        [string]$OldDocsDir = "docs"
    )
    
    Write-Host "===开始旧项目标准化 ===" -ForegroundColor Cyan
    Write-Host ""
    
    # 1. 预览
    Write-Host "步骤 1/6: 预览更改" -ForegroundColor Yellow
    Standardize-ExistingProject -OldCodeDir $OldCodeDir -OldDocsDir $OldDocsDir -DryRun $true
    
    Read-Host "`n按Enter继续执行实际更改，或Ctrl+C取消"
    
    # 2. 执行标准化
    Write-Host "`n步骤 2/6: 执行目录重命名" -ForegroundColor Yellow
    Standardize-ExistingProject -OldCodeDir $OldCodeDir -OldDocsDir $OldDocsDir -DryRun $false
    
    # 3. 更新引用
    Write-Host "`n步骤 3/6: 更新路径引用" -ForegroundColor Yellow
    Update-ProjectReferences -OldCodePath $OldCodeDir -OldDocsPath $OldDocsDir
    
    # 4. 更新README
    Write-Host "`n步骤 4/6: 更新README" -ForegroundColor Yellow
    Update-ReadmeTree
    Update-ReadmeTree -ReadmePath "项目文档\README.md"
    
    # 5. 验证
    Write-Host "`n步骤 5/6: 验证标准化" -ForegroundColor Yellow
    $valid = Test-Standardization
    
    # 6. 提交
    if ($valid) {
        Write-Host "`n步骤 6/6: 提交更改" -ForegroundColor Yellow
        git add -A
        git commit -m "refactor: 项目标准化`n`n- 重命名 $OldCodeDir  [代码目录]/`n- 重组 $OldDocsDir  [文档目录]/`n- 按标准分类所有文档`n- 更新所有路径引用`n- 更新README和目录树"
        Write-Host "`n✅ 标准化完成并已提交！" -ForegroundColor Green
    } else {
        Write-Host "`n⚠️ 请修复问题后再提交" -ForegroundColor Yellow
    }
}

# 使用：
# Complete-Standardization -OldCodeDir "src" -OldDocsDir "docs"
```

---

### 注意事项

1. **备份重要** ⚠️
   - 标准化前先提交当前状态
   - 确保可以回滚

2. **使用预览模式**
   - 先用 `-DryRun $true` 预览
   - 确认无误后再实际执行

3. **手动检查**
   - 自动分类可能不完美
   - 重要文件手动确认

4. **分步执行**
   - 可以分步骤执行
   - 每步验证后再继续

5. **更新引用**
   - 必须更新所有路径引用
   - 包括README、文档、配置文件

6. **遵循规则**
   - 参考 04-变更同步规则
   - 参考 05-README管理规范
## 🎯 AI行为规则

### 创建新项目时

1. **确认项目类型**
   - Web应用
   - API服务
   - 命令行工具
   - 数据科学项目

2. **执行创建脚本**
   - 使用上述PowerShell或Bash脚本
   - 根据项目类型调整 [代码目录]/ 结构

3. **确认可选目录**
   - 是否需要知识库？
   - 是否需要完成度检查？

4. **完成初始化**
   - 创建必需的README文件
   - 初始化Git仓库
   - 复制规则系统

### 组织现有项目时

1. **评估当前结构**
   - 识别代码目录
   - 识别文档位置
   - 识别特殊需求

2. **逐步迁移**
   - 重命名代码目录为 [代码目录]/
   - 组织项目文档到标准结构
   - 创建缺失的必需目录

3. **更新引用**
   - 批量更新路径引用
   - 更新README文档
   - 保持Git历史

---

## 📝 项目类型适配

### Web应用项目

```
[代码目录]/
 [后端目录]/
    src/
    tests/
    requirements.txt
 [前端目录]/
    src/
    public/
    package.json
 README.md
```

### API服务项目

```
[代码目录]/
 src/
    routes/
    models/
    controllers/
    middleware/
 tests/
 README.md
```

### 命令行工具

```
[代码目录]/
 src/
    main程序文件
 tests/
 README.md
 setup.py 或 package.json
```

### 数据科学项目

```
[代码目录]/
 notebooks/
 data/
    raw/
    processed/
 models/
 src/
 README.md
```

---

## 🔍 目录层级控制

### 最大层级限制
- **根目录**: 最多5层嵌套
- **project-code/**: 根据项目需要，但建议5层
- **项目文档/**: 最多3层

### 检查命令
```powershell
# PowerShell
Get-ChildItem -Recurse -Directory | ForEach-Object { 
    $depth = ($_.FullName -split '\\').Count 
    if ($depth > 5) { Write-Host "⚠️ 层级过深: $($_.FullName)" }
}
```

```bash
# Bash
find . -type d | awk -F'/' '{if(NF>6) print "⚠️ 层级过深:", $0}'
```

---

## ✅ 规则符合性

### 关联规则
- **00-核心工作原则**: 严格目录控制
- **01-文件操作规范**: 文件位置规范
- **02-目录管理规范**: 目录创建规范
- **03-文件命名规范**: 命名标准
- **04-变更同步规则**: 文档同步
- **05-README管理规范**: README维护
- **08-知识库管理规范**: 知识库只读

---

## 💡 最佳实践

### 1. 复用规则
- 将此规则文件复制到新项目
- 使用创建脚本快速初始化
- 保持所有项目结构一致

### 2. 适配调整
- [代码目录]/ 内部结构根据项目类型调整
- 可选目录按需创建
- 保持核心结构不变

### 3. 文档维护
- 及时更新项目文档/README.md
- 保持目录树与实际一致
- 定期归档过时内容

### 4. 团队协作
- 统一使用标准模板
- 降低理解成本
- 便于项目交接

---

**此规则可直接复制到任何新项目！** 🎯

**使用创建脚本一键生成标准目录结构！** 🚀
.DirectoryName -notmatch '[1234]-|9-' } |
    Select-Object FullName
```

### Step 2: 逐个读取文件

```
对每个文件：
1. 读取文件前20行
2. 提取关键信息：
   - 文件名特征（日期/关键词）
   - 标题内容
   - 前几段文字
```

### Step 3: 判断归属

```
根据内容判断：

包含"需求/架构/设计/功能说明/API设计"
 1-需求与设计/

文件名以YYYY-MM-DD开头 或 包含"开发/记录/报告/问题/修复"
 2-开发记录/YYYY-MM-DD/

包含"部署/配置/运维/环境/安装"
 3-部署运维/

包含"对照/完成度/检查/验证/Schema"
 4-完成度检查/

过时内容/历史文档/旧版本
 9-归档/
```

### Step 4: 移动文件

```powershell
# 按内容判断后移动
Move-Item $file.FullName "$targetDir\$($file.Name)"
```

### Step 5: 清理旧目录

```powershell
# 验证旧目录为空后删除
if ((Get-ChildItem $oldDir -Recurse).Count -eq 0) {
    Remove-Item $oldDir -Recurse -Force
}
```

### Step 6: 更新README

```
更新所有README.md：
- 项目文档/README.md
- 各子目录/README.md
- 项目根目录/README.md
```

---

## 📋 AI执行检查清单（更新）

**整理旧项目文档时，AI必须逐项检查**：

### 扫描阶段
- [ ] 列出所有旧目录
- [ ] 列出所有需要重新分类的文件
- [ ] 统计文件总数

### 分类阶段（逐个文件）
- [ ] 读取文件内容（前20行）
- [ ] 识别关键词
- [ ] 判断归属分类
- [ ] 移动到正确位置
- [ ] 记录处理结果

### 验证阶段
- [ ] 检查5个分类都已创建
- [ ] 检查日期文件按日期分类到子目录
- [ ] 检查旧目录已清空
- [ ] 删除所有旧目录

### 完成阶段
- [ ] 更新所有README.md
- [ ] 更新项目文档索引
- [ ] Git提交（保留历史）
- [ ] 报告处理结果

---
### AI强制执行清单

**整理文档目录时，AI必须**：

1. ✅ 检查目录是否符合5分类标准
2. ✅ 读取每个文件，判断正确归属
3. ✅ 移动文件到正确分类
4. ✅ 日期开头文件必须按日期分类到子目录
5. ✅ 更新所有README.md
6. ✅ 删除空的旧分类目录
7. ✅ 提交Git（保留历史）

**禁止**：
- ❌ 保留旧分类目录
- ❌ 创建5分类之外的目录
- ❌ 不看内容随意放置
### 4. [知识库目录]/ （可选）
**用途**: 源参考资料、学习资料  
**规则**: 只读，不可修改（参考08-知识库管理规范）  

---

## 🚀 自动创建脚本

### PowerShell脚本（Windows）

```powershell
# 创建标准项目结构
function New-StandardProject {
    param(
        [string]$ProjectName = "new-project",
        [bool]$IncludeKnowledgeBase = $false,
        [bool]$IncludeCompletionCheck = $false,
        [bool]$IncludeAIChat = $false
    )
    
    # 创建根目录
    New-Item -ItemType Directory -Path $ProjectName -Force | Out-Null
    Set-Location $ProjectName
    
    # 1. 创建 .windsurf/rules/
    New-Item -ItemType Directory -Path ".windsurf\rules" -Force | Out-Null
    Write-Host "✅ 创建 .windsurf\rules\"
    
    # 2. 创建 [代码目录]/
    New-Item -ItemType Directory -Path "project-code\backend" -Force | Out-Null
    New-Item -ItemType Directory -Path "project-code\frontend" -Force | Out-Null
    New-Item -ItemType Directory -Path "project-code\tests" -Force | Out-Null
    "# Project Code`n`n项目源代码目录" | Out-File "project-code\README.md" -Encoding UTF8
    Write-Host "✅ 创建 project-code\"
    
    # 3. 创建项目文档/（必需目录）
    $requiredDocs = @("1-需求与设计", "2-开发记录", "3-部署运维", "9-归档")
    foreach ($dir in $requiredDocs) {
        New-Item -ItemType Directory -Path "项目文档\$dir" -Force | Out-Null
        "# $dir`n" | Out-File "项目文档\$dir\README.md" -Encoding UTF8
    }
    Write-Host "✅ 创建项目文档\（必需）"
    
    # 4. 创建项目文档/（可选目录）
    if ($IncludeCompletionCheck) {
        New-Item -ItemType Directory -Path "项目文档\4-完成度检查\Schema对照" -Force | Out-Null
        New-Item -ItemType Directory -Path "项目文档\4-完成度检查\完成度报告" -Force | Out-Null
        Write-Host "✅ 创建项目文档\4-完成度检查\"
    }
    
    # 5. 创建项目文档/README.md
    $docReadme = @"
# $ProjectName - 项目文档

本目录包含项目的所有文档和记录。

## 📁 目录结构

``````
[文档目录]/
 [需求设计目录]/        需求、架构、设计
 [开发记录目录]/          开发过程记录
 [部署运维目录]/          部署、配置、运维
 [归档目录]/              历史归档
``````

**创建时间**: $(Get-Date -Format "yyyy-MM-dd")
"@
    $docReadme | Out-File "项目文档\README.md" -Encoding UTF8
    
    # 6. 创建知识库/（可选）
    if ($IncludeKnowledgeBase) {
        New-Item -ItemType Directory -Path "知识库" -Force | Out-Null
        "# 知识库`n`n源参考资料（只读）" | Out-File "知识库\README.md" -Encoding UTF8
        Write-Host "✅ 创建知识库\"
    }
    
    # 7. 创建根目录文件
    # .gitignore
    $gitignore = @"
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
.venv

# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Build
dist/
build/
*.egg-info/

# Temp
*.log
*.tmp
.env.local
"@
    $gitignore | Out-File ".gitignore" -Encoding UTF8
    
    # README.md
    $readme = @"
# $ProjectName

项目说明

## 📁 项目结构

``````
$ProjectName/
 .windsurf/rules/        规则系统
 [代码目录]/           项目代码
 [文档目录]/               项目文档
 README.md               本文件
``````

## 🚀 快速开始

（待补充）

## 📝 文档

详细文档请查看 [项目文档/](项目文档/README.md)

**创建时间**: $(Get-Date -Format "yyyy-MM-dd")
"@
    $readme | Out-File "README.md" -Encoding UTF8
    
    Write-Host "`n✅ 标准项目结构创建完成！"
    Write-Host "项目位置: $PWD"
}

# 使用示例：
# New-StandardProject -ProjectName "my-project" -IncludeAIChat $true
```

### Bash脚本（Linux/Mac）

```bash
#!/bin/bash
# 创建标准项目结构

create_standard_project() {
    local project_name=${1:-"new-project"}
    local include_kb=${2:-false}
    local include_check=${3:-false}
    local include_ai=${4:-false}
    
    mkdir -p "$project_name"
    cd "$project_name" || exit
    
    # 1. 创建 .windsurf/rules/
    mkdir -p .windsurf/rules
    echo "✅ 创建 .windsurf/rules/"
    
    # 2. 创建 [代码目录]/
    mkdir -p [代码目录]/{backend,frontend,tests}
    echo "# Project Code" > [代码目录]/README.md
    echo "✅ 创建 [代码目录]/"
    
    # 3. 创建项目文档/（必需）
    for dir in "1-需求与设计" "2-开发记录" "3-部署运维" "9-归档"; do
        mkdir -p "项目文档/$dir"
        echo "# $dir" > "项目文档/$dir/README.md"
    done
    echo "✅ 创建项目文档/（必需）"
    
    # 4. 可选目录
    if [ "$include_check" = true ]; then
        mkdir -p "项目文档/4-完成度检查"/{Schema对照,完成度报告}
        echo "✅ 创建项目文档/4-完成度检查/"
    fi
    
    # 5. README文件
    cat > [文档目录]/README.md <<EOF
# $project_name - 项目文档

创建时间: $(date +%Y-%m-%d)
EOF
    
    if [ "$include_kb" = true ]; then
        mkdir -p "知识库"
        echo "# 知识库" > "知识库/README.md"
        echo "✅ 创建知识库/"
    fi
    
    # 6. .gitignore
    cat > .gitignore <<EOF
__pycache__/
node_modules/
.vscode/
.DS_Store
*.log
.env.local
EOF
    
    # 7. 根README
    cat > README.md <<EOF
# $project_name

创建时间: $(date +%Y-%m--%d)
EOF
    
    echo ""
    echo "✅ 标准项目结构创建完成！"
}

# 使用示例：
# create_standard_project "my-project" true false true
```

---

## ✅ 创建检查清单

### 必需项（所有项目）
- [ ] .windsurf/rules/ 目录
- [ ] [代码目录]/ 目录及子目录
- [ ] [文档目录]/1-需求与设计/
- [ ] [文档目录]/2-开发记录/
- [ ] [文档目录]/3-部署运维/
- [ ] [文档目录]/9-归档/
- [ ] [文档目录]/README.md
- [ ] 根目录 README.md
- [ ] .gitignore

### 可选项（按需创建）
- [ ] [知识库目录]/ 目录
- [ ] [文档目录]/4-完成度检查/
- [ ] [文档目录]/项目状态.json

---


---

## 🔄 旧项目标准化流程

### 适用场景
- 现有项目需要标准化
- 目录结构混乱需要整理
- 迁移到新的标准模板

---

### 标准化步骤

#### Step 1: 评估现有结构

**检查清单**：
```powershell
# 列出根目录所有项
Get-ChildItem -Force | Select-Object Name, Mode

# 识别代码目录
# 常见名称: src/, app/, [后端目录]/, [前端目录]/, code/

# 识别文档目录
# 常见名称: docs/, 文档/, 项目记录/, documentation/

# 识别其他目录
# tests/, scripts/, data/, config/
```

**记录内容**：
- [ ] 代码目录名称和位置
- [ ] 文档目录名称和位置
- [ ] 测试文件位置
- [ ] 配置文件位置
- [ ] 其他重要目录

---

#### Step 2: 制定迁移计划

**目录映射**：
```
现有目录  标准目录

代码目录（src/app/code/等）  [代码目录]/
文档目录（docs/文档/等）  [文档目录]/
测试目录（test/tests/等）  [代码目录]/tests/
临时文件  [文档目录]/9-归档/
```

**文件分类**：
```
现有文件  标准位置

需求文档  [文档目录]/1-需求与设计/
开发日志  [文档目录]/2-开发记录/
部署文档  [文档目录]/3-部署运维/
对照文档  [文档目录]/4-完成度检查/
过时文档  [文档目录]/9-归档/
```

---

#### Step 3: 执行目录重命名

**PowerShell脚本**：
```powershell
# 标准化旧项目目录结构
function Standardize-ExistingProject {
    param(
        [string]$OldCodeDir = "",      # 旧代码目录名
        [string]$OldDocsDir = "",      # 旧文档目录名
        [bool]$DryRun = $true          # 预览模式
    )
    
    Write-Host "=== 旧项目标准化工具 ===" -ForegroundColor Cyan
    
    # 1. 重命名代码目录
    if ($OldCodeDir -and (Test-Path $OldCodeDir)) {
        if ($DryRun) {
            Write-Host "[预览] 将重命名: $OldCodeDir  [代码目录]/" -ForegroundColor Yellow
        } else {
            git mv $OldCodeDir project-code
            Write-Host "✅ 已重命名: $OldCodeDir  [代码目录]/" -ForegroundColor Green
        }
    }
    
    # 2. 重命名文档目录
    if ($OldDocsDir -and (Test-Path $OldDocsDir)) {
        if ($DryRun) {
            Write-Host "[预览] 将重命名: $OldDocsDir  [文档目录]/" -ForegroundColor Yellow
        } else {
            git mv $OldDocsDir 项目文档
            Write-Host "✅ 已重命名: $OldDocsDir  [文档目录]/" -ForegroundColor Green
        }
    }
    
    # 3. 分类文档到标准子目录
    if (Test-Path "项目文档") {
        if ($DryRun) {
            Write-Host "[预览] 将创建标准子目录" -ForegroundColor Yellow
        } else {
            $requiredDirs = @("1-需求与设计", "2-开发记录", "3-部署运维", "9-归档")
            foreach ($dir in $requiredDirs) {
                $path = "项目文档\$dir"
                if (-not (Test-Path $path)) {
                    New-Item -ItemType Directory -Path $path -Force | Out-Null
                    Write-Host "✅ 已创建: $path" -ForegroundColor Green
                }
            }
        }
    }
    
    # 4. 自动分类文件
    if (-not $DryRun -and (Test-Path "项目文档")) {
        Write-Host "`n开始自动分类文件..." -ForegroundColor Cyan
        
        Get-ChildItem "项目文档" -File | ForEach-Object {
            $file = $_
            $moved = $false
            
            # 根据文件名模式分类
            if ($file.Name -match '^\d{4}-\d{2}-\d{2}') {
                # 日期开头的记录类文档
                $dest = "项目文档\2-开发记录\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [开发记录目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '需求|设计|架构') {
                $dest = "项目文档\1-需求与设计\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [需求设计目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '部署|配置|运维') {
                $dest = "项目文档\3-部署运维\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [部署运维目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            elseif ($file.Name -match '对照|完成度|检查') {
                # 如果不存在，创建可选目录
                if (-not (Test-Path "项目文档\4-完成度检查")) {
                    New-Item -ItemType Directory -Path "项目文档\4-完成度检查" -Force | Out-Null
                }
                $dest = "项目文档\4-完成度检查\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [完成度检查目录]/: $($file.Name)" -ForegroundColor Gray
                $moved = $true
            }
            
            # 未匹配的放到归档
            if (-not $moved -and $file.Name -ne "README.md" -and $file.Name -ne "项目状态.json") {
                $dest = "项目文档\9-归档\$($file.Name)"
                Move-Item $file.FullName $dest
                Write-Host "   [归档目录]/: $($file.Name)" -ForegroundColor Gray
            }
        }
    }
    
    if ($DryRun) {
        Write-Host "`n=== 这是预览模式，没有实际执行 ===" -ForegroundColor Yellow
        Write-Host "运行时设置 -DryRun `$false 来实际执行" -ForegroundColor Yellow
    } else {
        Write-Host "`n✅ 标准化完成！" -ForegroundColor Green
    }
}

# 使用示例：
# 1. 预览模式（不执行，只显示将要做什么）
# Standardize-ExistingProject -OldCodeDir "src" -OldDocsDir "docs" -DryRun $true

# 2. 实际执行
# Standardize-ExistingProject -OldCodeDir "src" -OldDocsDir "docs" -DryRun $false
```

---

#### Step 4: 批量更新引用

**自动更新脚本**：
```powershell
# 批量更新所有文件中的路径引用
function Update-ProjectReferences {
    param(
        [string]$OldCodePath = "",
        [string]$NewCodePath = "project-code",
        [string]$OldDocsPath = "",
        [string]$NewDocsPath = "项目文档"
    )
    
    Write-Host "=== 批量更新路径引用 ===" -ForegroundColor Cyan
    
    # 创建替换映射
    $replacements = @{}
    if ($OldCodePath) {
        $replacements[$OldCodePath] = $NewCodePath
    }
    if ($OldDocsPath) {
        $replacements[$OldDocsPath] = $NewDocsPath
    }
    
    # 扫描所有Markdown文件
    $files = Get-ChildItem -Path "." -Filter "*.md" -Recurse -Exclude node_modules,venv,__pycache__ | 
        Where-Object { $_.FullName -notmatch 'node_modules|venv|__pycache__' }
    
    $updatedCount = 0
    
    foreach ($file in $files) {
        $content = Get-Content $file.FullName -Raw -Encoding UTF8 -ErrorAction SilentlyContinue
        if ($content) {
            $updated = $false
            
            foreach ($old in $replacements.Keys) {
                if ($content -match [regex]::Escape($old)) {
                    $content = $content -replace [regex]::Escape($old), $replacements[$old]
                    $updated = $true
                }
            }
            
            if ($updated) {
                [System.IO.File]::WriteAllText($file.FullName, $content, [System.Text.UTF8Encoding]::new($false))
                $updatedCount++
                Write-Host "  ✅ $($file.Name)" -ForegroundColor Green
            }
        }
    }
    
    Write-Host "`n✅ 已更新 $updatedCount 个文件的引用" -ForegroundColor Green
}

# 使用示例：
# Update-ProjectReferences -OldCodePath "src" -OldDocsPath "docs"
```

---

#### Step 5: 更新README和目录树

**自动更新README**：
```powershell
# 更新README.md中的目录树
function Update-ReadmeTree {
    param(
        [string]$ReadmePath = "README.md"
    )
    
    if (-not (Test-Path $ReadmePath)) {
        Write-Host "README.md 不存在" -ForegroundColor Red
        return
    }
    
    Write-Host "=== 更新README目录树 ===" -ForegroundColor Cyan
    
    # 生成新的目录树
    $tree = @"
``````
项目结构/
 .windsurf/rules/        规则系统
 [代码目录]/           项目代码
    [后端目录]/
    [前端目录]/
    tests/
 [文档目录]/               项目文档
    [需求设计目录]/
    [开发记录目录]/
    [部署运维目录]/
    [归档目录]/
 .gitignore
 README.md
``````
"@
    
    # 读取README内容
    $content = Get-Content $ReadmePath -Raw -Encoding UTF8
    
    # 查找并替换旧的目录树（在```之间的内容）
    if ($content -match '(?s)```[^`]*项目.*?```') {
        $content = $content -replace '(?s)```[^`]*项目.*?```', $tree
        [System.IO.File]::WriteAllText($ReadmePath, $content, [System.Text.UTF8Encoding]::new($false))
        Write-Host "✅ 已更新 $ReadmePath 中的目录树" -ForegroundColor Green
    } else {
        Write-Host "⚠️ 未找到目录树，请手动添加" -ForegroundColor Yellow
    }
}

# 使用示例：
# Update-ReadmeTree
# Update-ReadmeTree -ReadmePath "项目文档\README.md"
```

---

#### Step 6: 验证和提交

**验证清单**：
```powershell
# 标准化验证
function Test-Standardization {
    Write-Host "=== 标准化验证 ===" -ForegroundColor Cyan
    
    $issues = @()
    
    # 1. 检查必需目录
    $requiredDirs = @(
        ".windsurf\rules",
        "project-code",
        "项目文档",
        "项目文档\1-需求与设计",
        "项目文档\2-开发记录",
        "项目文档\3-部署运维",
        "项目文档\9-归档"
    )
    
    foreach ($dir in $requiredDirs) {
        if (Test-Path $dir) {
            Write-Host "  ✅ $dir" -ForegroundColor Green
        } else {
            Write-Host "  ❌ $dir (缺失)" -ForegroundColor Red
            $issues += "缺失必需目录: $dir"
        }
    }
    
    # 2. 检查必需文件
    $requiredFiles = @(
        "README.md",
        ".gitignore",
        "项目文档\README.md"
    )
    
    foreach ($file in $requiredFiles) {
        if (Test-Path $file) {
            Write-Host "  ✅ $file" -ForegroundColor Green
        } else {
            Write-Host "  ❌ $file (缺失)" -ForegroundColor Red
            $issues += "缺失必需文件: $file"
        }
    }
    
    # 3. 检查项目文档根目录是否有文件（除了README和状态文件）
    if (Test-Path "项目文档") {
        $rootFiles = Get-ChildItem "项目文档" -File | 
            Where-Object { $_.Name -ne "README.md" -and $_.Name -ne "项目状态.json" }
        
        if ($rootFiles.Count -gt 0) {
            Write-Host "  ⚠️ 项目文档根目录有 $($rootFiles.Count) 个文件需要分类" -ForegroundColor Yellow
            $rootFiles | ForEach-Object {
                Write-Host "     - $($_.Name)" -ForegroundColor Gray
            }
            $issues += "项目文档根目录有未分类文件"
        }
    }
    
    # 4. 报告结果
    Write-Host ""
    if ($issues.Count -eq 0) {
        Write-Host "✅ 标准化验证通过！" -ForegroundColor Green
        return $true
    } else {
        Write-Host "❌ 发现 $($issues.Count) 个问题：" -ForegroundColor Red
        $issues | ForEach-Object { Write-Host "  - $_" -ForegroundColor Red }
        return $false
    }
}

# 使用示例：
# Test-Standardization
```

**Git提交**：
```powershell
# 提交标准化更改
git add -A
git status

# 提交
git commit -m "refactor: 项目标准化

- 重命名代码目录为 [代码目录]/
- 重组文档目录为 [文档目录]/
- 按标准分类所有文档
- 更新所有路径引用
- 更新README和目录树"
```

---

### 完整标准化流程示例

```powershell
# 旧项目标准化完整流程
function Complete-Standardization {
    param(
        [string]$OldCodeDir = "src",
        [string]$OldDocsDir = "docs"
    )
    
    Write-Host "===开始旧项目标准化 ===" -ForegroundColor Cyan
    Write-Host ""
    
    # 1. 预览
    Write-Host "步骤 1/6: 预览更改" -ForegroundColor Yellow
    Standardize-ExistingProject -OldCodeDir $OldCodeDir -OldDocsDir $OldDocsDir -DryRun $true
    
    Read-Host "`n按Enter继续执行实际更改，或Ctrl+C取消"
    
    # 2. 执行标准化
    Write-Host "`n步骤 2/6: 执行目录重命名" -ForegroundColor Yellow
    Standardize-ExistingProject -OldCodeDir $OldCodeDir -OldDocsDir $OldDocsDir -DryRun $false
    
    # 3. 更新引用
    Write-Host "`n步骤 3/6: 更新路径引用" -ForegroundColor Yellow
    Update-ProjectReferences -OldCodePath $OldCodeDir -OldDocsPath $OldDocsDir
    
    # 4. 更新README
    Write-Host "`n步骤 4/6: 更新README" -ForegroundColor Yellow
    Update-ReadmeTree
    Update-ReadmeTree -ReadmePath "项目文档\README.md"
    
    # 5. 验证
    Write-Host "`n步骤 5/6: 验证标准化" -ForegroundColor Yellow
    $valid = Test-Standardization
    
    # 6. 提交
    if ($valid) {
        Write-Host "`n步骤 6/6: 提交更改" -ForegroundColor Yellow
        git add -A
        git commit -m "refactor: 项目标准化`n`n- 重命名 $OldCodeDir  [代码目录]/`n- 重组 $OldDocsDir  [文档目录]/`n- 按标准分类所有文档`n- 更新所有路径引用`n- 更新README和目录树"
        Write-Host "`n✅ 标准化完成并已提交！" -ForegroundColor Green
    } else {
        Write-Host "`n⚠️ 请修复问题后再提交" -ForegroundColor Yellow
    }
}

# 使用：
# Complete-Standardization -OldCodeDir "src" -OldDocsDir "docs"
```

---

### 注意事项

1. **备份重要** ⚠️
   - 标准化前先提交当前状态
   - 确保可以回滚

2. **使用预览模式**
   - 先用 `-DryRun $true` 预览
   - 确认无误后再实际执行

3. **手动检查**
   - 自动分类可能不完美
   - 重要文件手动确认

4. **分步执行**
   - 可以分步骤执行
   - 每步验证后再继续

5. **更新引用**
   - 必须更新所有路径引用
   - 包括README、文档、配置文件

6. **遵循规则**
   - 参考 04-变更同步规则
   - 参考 05-README管理规范
## 🎯 AI行为规则

### 创建新项目时

1. **确认项目类型**
   - Web应用
   - API服务
   - 命令行工具
   - 数据科学项目

2. **执行创建脚本**
   - 使用上述PowerShell或Bash脚本
   - 根据项目类型调整 [代码目录]/ 结构

3. **确认可选目录**
   - 是否需要知识库？
   - 是否需要完成度检查？

4. **完成初始化**
   - 创建必需的README文件
   - 初始化Git仓库
   - 复制规则系统

### 组织现有项目时

1. **评估当前结构**
   - 识别代码目录
   - 识别文档位置
   - 识别特殊需求

2. **逐步迁移**
   - 重命名代码目录为 [代码目录]/
   - 组织项目文档到标准结构
   - 创建缺失的必需目录

3. **更新引用**
   - 批量更新路径引用
   - 更新README文档
   - 保持Git历史

---

## 📝 项目类型适配

### Web应用项目

```
[代码目录]/
 [后端目录]/
    src/
    tests/
    requirements.txt
 [前端目录]/
    src/
    public/
    package.json
 README.md
```

### API服务项目

```
[代码目录]/
 src/
    routes/
    models/
    controllers/
    middleware/
 tests/
 README.md
```

### 命令行工具

```
[代码目录]/
 src/
    main程序文件
 tests/
 README.md
 setup.py 或 package.json
```

### 数据科学项目

```
[代码目录]/
 notebooks/
 data/
    raw/
    processed/
 models/
 src/
 README.md
```

---

## 🔍 目录层级控制

### 最大层级限制
- **根目录**: 最多5层嵌套
- **project-code/**: 根据项目需要，但建议5层
- **项目文档/**: 最多3层

### 检查命令
```powershell
# PowerShell
Get-ChildItem -Recurse -Directory | ForEach-Object { 
    $depth = ($_.FullName -split '\\').Count 
    if ($depth > 5) { Write-Host "⚠️ 层级过深: $($_.FullName)" }
}
```

```bash
# Bash
find . -type d | awk -F'/' '{if(NF>6) print "⚠️ 层级过深:", $0}'
```

---

## ✅ 规则符合性

### 关联规则
- **00-核心工作原则**: 严格目录控制
- **01-文件操作规范**: 文件位置规范
- **02-目录管理规范**: 目录创建规范
- **03-文件命名规范**: 命名标准
- **04-变更同步规则**: 文档同步
- **05-README管理规范**: README维护
- **08-知识库管理规范**: 知识库只读

---

## 💡 最佳实践

### 1. 复用规则
- 将此规则文件复制到新项目
- 使用创建脚本快速初始化
- 保持所有项目结构一致

### 2. 适配调整
- [代码目录]/ 内部结构根据项目类型调整
- 可选目录按需创建
- 保持核心结构不变

### 3. 文档维护
- 及时更新项目文档/README.md
- 保持目录树与实际一致
- 定期归档过时内容

### 4. 团队协作
- 统一使用标准模板
- 降低理解成本
- 便于项目交接

---

**此规则可直接复制到任何新项目！** 🎯

**使用创建脚本一键生成标准目录结构！** 🚀
